# -*- Makefile -*-
#----------------------------------------------------------------------------
#       GNU Makefile
#
# @file GNUmakefile.TAO_Core_idl
#
# This file was automatically generated by MPC.  Any changes made directly to
# this file will be lost the next time it is generated.
#
#----------------------------------------------------------------------------
MAKEFILE         = GNUmakefile.TAO_Core_idl
DEPENDENCY_FILE  = .depend.TAO_Core_idl

IDL_DEPENDENCY_FILE1 = .depend.TAO_Core_idl_Idl1
IDL_DEPENDENCY_FILE2 = .depend.TAO_Core_idl_Idl2
IDL_DEPENDENCY_FILE3 = .depend.TAO_Core_idl_Idl3
IDL_DEPENDENCY_FILE4 = .depend.TAO_Core_idl_Idl4
IDL_DEPENDENCY_FILE5 = .depend.TAO_Core_idl_Idl5
IDL_DEPENDENCY_FILE6 = .depend.TAO_Core_idl_Idl6
IDL_DEPENDENCY_FILE7 = .depend.TAO_Core_idl_Idl7
IDL_DEPENDENCY_FILE8 = .depend.TAO_Core_idl_Idl8
IDL_DEPENDENCY_FILE9 = .depend.TAO_Core_idl_Idl9
IDL_DEPENDENCY_FILE10 = .depend.TAO_Core_idl_Idl10
IDL_DEPENDENCY_FILE11 = .depend.TAO_Core_idl_Idl11
IDL_DEPENDENCY_FILE12 = .depend.TAO_Core_idl_Idl12
IDL_DEPENDENCY_FILE13 = .depend.TAO_Core_idl_Idl13
IDL_DEPENDENCY_FILE14 = .depend.TAO_Core_idl_Idl14
IDL_DEPENDENCY_FILE15 = .depend.TAO_Core_idl_Idl15
IDL_DEPENDENCY_FILE16 = .depend.TAO_Core_idl_Idl16
IDL_DEPENDENCY_FILE17 = .depend.TAO_Core_idl_Idl17
IDL_DEPENDENCY_FILE18 = .depend.TAO_Core_idl_Idl18
IDL_DEPENDENCY_FILE19 = .depend.TAO_Core_idl_Idl19
IDL_DEPENDENCY_FILE20 = .depend.TAO_Core_idl_Idl20
IDL_DEPENDENCY_FILE21 = .depend.TAO_Core_idl_Idl21
IDL_DEPENDENCY_FILE22 = .depend.TAO_Core_idl_Idl22
IDL_DEPENDENCY_FILE23 = .depend.TAO_Core_idl_Idl23
IDL_DEPENDENCY_FILE24 = .depend.TAO_Core_idl_Idl24
IDL_DEPENDENCY_FILE25 = .depend.TAO_Core_idl_Idl25
IDL_DEPENDENCY_FILE26 = .depend.TAO_Core_idl_Idl26
IDL_DEPENDENCY_FILE27 = .depend.TAO_Core_idl_Idl27
IDL_DEPENDENCY_FILE28 = .depend.TAO_Core_idl_Idl28
IDL_DEPENDENCY_FILE29 = .depend.TAO_Core_idl_Idl29
IDL_DEPENDENCY_FILE30 = .depend.TAO_Core_idl_Idl30
IDL_DEPENDENCY_FILE31 = .depend.TAO_Core_idl_Idl31
IDL_DEPENDENCY_FILE32 = .depend.TAO_Core_idl_Idl32
IDL_DEPENDENCY_FILE33 = .depend.TAO_Core_idl_Idl33
IDL_DEPENDENCY_FILE34 = .depend.TAO_Core_idl_Idl34
IDL_DEPENDENCY_FILE35 = .depend.TAO_Core_idl_Idl35

IDL_DEPENDENCY_FILES += \
	.depend.TAO_Core_idl_Idl1 \
	.depend.TAO_Core_idl_Idl2 \
	.depend.TAO_Core_idl_Idl3 \
	.depend.TAO_Core_idl_Idl4 \
	.depend.TAO_Core_idl_Idl5 \
	.depend.TAO_Core_idl_Idl6 \
	.depend.TAO_Core_idl_Idl7 \
	.depend.TAO_Core_idl_Idl8 \
	.depend.TAO_Core_idl_Idl9 \
	.depend.TAO_Core_idl_Idl10 \
	.depend.TAO_Core_idl_Idl11 \
	.depend.TAO_Core_idl_Idl12 \
	.depend.TAO_Core_idl_Idl13 \
	.depend.TAO_Core_idl_Idl14 \
	.depend.TAO_Core_idl_Idl15 \
	.depend.TAO_Core_idl_Idl16 \
	.depend.TAO_Core_idl_Idl17 \
	.depend.TAO_Core_idl_Idl18 \
	.depend.TAO_Core_idl_Idl19 \
	.depend.TAO_Core_idl_Idl20 \
	.depend.TAO_Core_idl_Idl21 \
	.depend.TAO_Core_idl_Idl22 \
	.depend.TAO_Core_idl_Idl23 \
	.depend.TAO_Core_idl_Idl24 \
	.depend.TAO_Core_idl_Idl25 \
	.depend.TAO_Core_idl_Idl26 \
	.depend.TAO_Core_idl_Idl27 \
	.depend.TAO_Core_idl_Idl28 \
	.depend.TAO_Core_idl_Idl29 \
	.depend.TAO_Core_idl_Idl30 \
	.depend.TAO_Core_idl_Idl31 \
	.depend.TAO_Core_idl_Idl32 \
	.depend.TAO_Core_idl_Idl33 \
	.depend.TAO_Core_idl_Idl34 \
	.depend.TAO_Core_idl_Idl35

LIB_PREFIX      ?= lib

FILES = \

IDL_DEPS_FLAGS1 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h
IDL_DEPS1 = GIOP.pidl

IDL_DEPS_FLAGS2 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS2 = CONV_FRAME.pidl

IDL_DEPS_FLAGS3 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS3 = Current.pidl

IDL_DEPS_FLAGS4 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS4 = IIOP.pidl

IDL_DEPS_FLAGS5 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS5 = IIOP_Endpoints.pidl

IDL_DEPS_FLAGS6 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS6 = IOP.pidl

IDL_DEPS_FLAGS7 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS7 = Messaging_PolicyValue.pidl

IDL_DEPS_FLAGS8 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS8 = Messaging_SyncScope.pidl

IDL_DEPS_FLAGS9 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS9 = ObjectIdList.pidl

IDL_DEPS_FLAGS10 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS10 = orb_types.pidl

IDL_DEPS_FLAGS11 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS11 = Policy_Manager.pidl

IDL_DEPS_FLAGS12 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS12 = Policy_Current.pidl

IDL_DEPS_FLAGS13 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS13 = PI_Forward.pidl

IDL_DEPS_FLAGS14 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS14 = PortableInterceptor.pidl

IDL_DEPS_FLAGS15 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS15 = Services.pidl

IDL_DEPS_FLAGS16 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS16 = TAO.pidl

IDL_DEPS_FLAGS17 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci
IDL_DEPS17 = TimeBase.pidl

IDL_DEPS_FLAGS18 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Sa
IDL_DEPS18 = Policy_Forward.pidl

IDL_DEPS_FLAGS19 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Sat
IDL_DEPS19 = ParameterMode.pidl

IDL_DEPS_FLAGS20 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS20 = BooleanSeq.pidl

IDL_DEPS_FLAGS21 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS21 = CharSeq.pidl

IDL_DEPS_FLAGS22 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS22 = DoubleSeq.pidl

IDL_DEPS_FLAGS23 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS23 = FloatSeq.pidl

IDL_DEPS_FLAGS24 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS24 = LongDoubleSeq.pidl

IDL_DEPS_FLAGS25 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS25 = LongLongSeq.pidl

IDL_DEPS_FLAGS26 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS26 = LongSeq.pidl

IDL_DEPS_FLAGS27 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS27 = OctetSeq.pidl

IDL_DEPS_FLAGS28 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS28 = ShortSeq.pidl

IDL_DEPS_FLAGS29 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS29 = StringSeq.pidl

IDL_DEPS_FLAGS30 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS30 = ULongLongSeq.pidl

IDL_DEPS_FLAGS31 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS31 = ULongSeq.pidl

IDL_DEPS_FLAGS32 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS32 = UShortSeq.pidl

IDL_DEPS_FLAGS33 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS33 = WCharSeq.pidl

IDL_DEPS_FLAGS34 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata
IDL_DEPS34 = WStringSeq.pidl

IDL_DEPS_FLAGS35 = $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -GT -oS PortableServer -Gd -Wb,safe_include=tao/PolicyC.h -Wb,skel_export_macro=TAO_PortableServer_Export -Wb,skel_export_include=tao/PortableServer/portableserver_export.h
IDL_DEPS35 = Policy.pidl



LIBPATHS := .

#----------------------------------------------------------------------------
#       Include macros and targets
#----------------------------------------------------------------------------
TAO_IDL = ../../bin/tao_idl
TAO_IDL_DEP = ../../bin/tao_idl$(EXEEXT)
TAO_IDLFLAGS = -Wb,pre_include=ace/pre.h -Wb,post_include=ace/post.h -I..$(if $(ARCH), -g $(call ADD_QUOTE,$(call ADD_ARCH,$(ACE_ROOT)/bin/ace_gperf)))

PRJ_TYPE = library

COLLAPSE_SLASHES = $(if $(findstring //,$(1)),$(call COLLAPSE_SLASHES,$(subst //,/,$(1))),$(1))
INSLIB ?= $(call COLLAPSE_SLASHES,.)
ifeq ($(INSLIB),.)
  ifeq ($(CURDIR),)
    ifeq ($(PWD),)
      PWD=$(shell pwd)
    endif
  else
    PWD=$(CURDIR)
  endif
  INSLIB = $(PWD)
endif
OUTPUT_DIRECTORY = $(INSLIB)

include $(ACE_ROOT)/include/makeinclude/wrapper_macros.GNU


GNUACE_PROJECT_VERSION ?= $(ACE_VERSION)

# To build multiple targets in the same directory on AIX, it works
# best to have a template directory per project.
# The compiler/linker isn't too smart about instantiating templates...
ifdef TEMPINCDIR
TEMPINCDIR := $(TEMPINCDIR)/TAO_Core_idl
all: $(TEMPINCDIR)
endif

ifneq ($(OUTPUT_DIRECTORY),)
.PHONY: create_output_directory.local
all: create_output_directory.local
create_output_directory.local:
	-@$(MKDIR) "$(OUTPUT_DIRECTORY)" $(ACE_NUL_STDERR)
endif

LIBCHECK = 1
ifneq ($(LIBCHECK), 1)
  all: lib_warning
endif


include $(ACE_ROOT)/include/makeinclude/macros.GNU
include $(ACE_ROOT)/include/makeinclude/rules.common.GNU
include $(ACE_ROOT)/include/makeinclude/rules.nonested.GNU
include $(ACE_ROOT)/include/makeinclude/rules.local.GNU
ifeq ($(VXWORKSLINK),1)
include $(TGT_DIR)/h/make/rules.$(PRJ_TYPE)
endif

ifeq ($(VXWORKSLINK),1)
LDLIBPATH     = -L.
else
LDFLAGS      += -L. $(if $(ARCH),-L./$(ARCH))
endif

#----------------------------------------------------------------------------
#       Local targets
#----------------------------------------------------------------------------
lib_warning:
	@echo TAO_Core_idl will not be built due to the following missing library: $(LIBCHECK) >&2

## Some OS's have /bin/test others only have /usr/bin/test
ifeq ($(wildcard /bin/test), /bin/test)
  TEST_EXE = /bin/test
else
ifeq ($(wildcard /usr/bin/test), /usr/bin/test)
  TEST_EXE = /usr/bin/test
endif
endif

SPACE = $(should_be_unset) $(should_be_unset)
export DYLD_LIBRARY_PATH := $(DYLD_LIBRARY_PATH):../../lib$(if $(ARCH),:../../lib/$(ARCH))
export LD_LIBRARY_PATH   := $(LD_LIBRARY_PATH):../../lib$(if $(ARCH),:../../lib/$(ARCH))
export SHLIB_PATH        := $(SHLIB_PATH):../../lib$(if $(ARCH),:../../lib/$(ARCH))
export LIBPATH           := $(LIBPATH):../../lib$(if $(ARCH),:../../lib/$(ARCH))
export PATH              := $(PATH):../../lib$(if $(ARCH),:../../lib/$(ARCH))

GENERATED_DIRTY += GIOPS.h GIOPC.h AnyTypeCode/GIOPA.h GIOPC.inl GIOPC.cpp AnyTypeCode/GIOPA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "GIOP.pidl" -nt "GIOPS.h" 2> /dev/null || $(TEST_EXE) "GIOP.pidl" -nt "GIOPC.h" 2> /dev/null || $(TEST_EXE) "GIOP.pidl" -nt "AnyTypeCode/GIOPA.h" 2> /dev/null || $(TEST_EXE) "GIOP.pidl" -nt "GIOPC.inl" 2> /dev/null || $(TEST_EXE) "GIOP.pidl" -nt "GIOPC.cpp" 2> /dev/null || $(TEST_EXE) "GIOP.pidl" -nt "AnyTypeCode/GIOPA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "GIOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "GIOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/GIOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "GIOPC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "GIOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/GIOPA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "GIOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "GIOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/GIOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "GIOPC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "GIOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/GIOPA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "GIOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "GIOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/GIOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "GIOPC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "GIOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/GIOPA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
GIOPS.h GIOPC.h AnyTypeCode/GIOPA.h GIOPC.inl GIOPC.cpp AnyTypeCode/GIOPA.cpp: GIOP.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h GIOP.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
GIOPS.h GIOPC.h AnyTypeCode/GIOPA.h GIOPC.inl GIOPC.cpp AnyTypeCode/GIOPA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += CONV_FRAMES.h CONV_FRAMEC.h AnyTypeCode/CONV_FRAMEA.h CONV_FRAMEC.cpp AnyTypeCode/CONV_FRAMEA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CONV_FRAME.pidl" -nt "CONV_FRAMES.h" 2> /dev/null || $(TEST_EXE) "CONV_FRAME.pidl" -nt "CONV_FRAMEC.h" 2> /dev/null || $(TEST_EXE) "CONV_FRAME.pidl" -nt "AnyTypeCode/CONV_FRAMEA.h" 2> /dev/null || $(TEST_EXE) "CONV_FRAME.pidl" -nt "CONV_FRAMEC.cpp" 2> /dev/null || $(TEST_EXE) "CONV_FRAME.pidl" -nt "AnyTypeCode/CONV_FRAMEA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CONV_FRAMES.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CONV_FRAMEC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/CONV_FRAMEA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CONV_FRAMEC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/CONV_FRAMEA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CONV_FRAMES.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CONV_FRAMEC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/CONV_FRAMEA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CONV_FRAMEC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/CONV_FRAMEA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CONV_FRAMES.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CONV_FRAMEC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/CONV_FRAMEA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CONV_FRAMEC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/CONV_FRAMEA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CONV_FRAMES.h CONV_FRAMEC.h AnyTypeCode/CONV_FRAMEA.h CONV_FRAMEC.cpp AnyTypeCode/CONV_FRAMEA.cpp: CONV_FRAME.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci CONV_FRAME.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
CONV_FRAMES.h CONV_FRAMEC.h AnyTypeCode/CONV_FRAMEA.h CONV_FRAMEC.cpp AnyTypeCode/CONV_FRAMEA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += CurrentS.h CurrentC.h AnyTypeCode/CurrentA.h CurrentC.cpp AnyTypeCode/CurrentA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Current.pidl" -nt "CurrentS.h" 2> /dev/null || $(TEST_EXE) "Current.pidl" -nt "CurrentC.h" 2> /dev/null || $(TEST_EXE) "Current.pidl" -nt "AnyTypeCode/CurrentA.h" 2> /dev/null || $(TEST_EXE) "Current.pidl" -nt "CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "Current.pidl" -nt "AnyTypeCode/CurrentA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CurrentS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CurrentC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/CurrentA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/CurrentA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CurrentS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CurrentC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/CurrentA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/CurrentA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CurrentS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CurrentC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/CurrentA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/CurrentA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CurrentS.h CurrentC.h AnyTypeCode/CurrentA.h CurrentC.cpp AnyTypeCode/CurrentA.cpp: Current.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci Current.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
CurrentS.h CurrentC.h AnyTypeCode/CurrentA.h CurrentC.cpp AnyTypeCode/CurrentA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += IIOPS.h IIOPC.h AnyTypeCode/IIOPA.h IIOPC.cpp AnyTypeCode/IIOPA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "IIOP.pidl" -nt "IIOPS.h" 2> /dev/null || $(TEST_EXE) "IIOP.pidl" -nt "IIOPC.h" 2> /dev/null || $(TEST_EXE) "IIOP.pidl" -nt "AnyTypeCode/IIOPA.h" 2> /dev/null || $(TEST_EXE) "IIOP.pidl" -nt "IIOPC.cpp" 2> /dev/null || $(TEST_EXE) "IIOP.pidl" -nt "AnyTypeCode/IIOPA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IIOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IIOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/IIOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IIOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/IIOPA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IIOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IIOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/IIOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IIOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/IIOPA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IIOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IIOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/IIOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IIOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/IIOPA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
IIOPS.h IIOPC.h AnyTypeCode/IIOPA.h IIOPC.cpp AnyTypeCode/IIOPA.cpp: IIOP.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci IIOP.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
IIOPS.h IIOPC.h AnyTypeCode/IIOPA.h IIOPC.cpp AnyTypeCode/IIOPA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += IIOP_EndpointsS.h IIOP_EndpointsC.h AnyTypeCode/IIOP_EndpointsA.h IIOP_EndpointsC.cpp AnyTypeCode/IIOP_EndpointsA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "IIOP_Endpoints.pidl" -nt "IIOP_EndpointsS.h" 2> /dev/null || $(TEST_EXE) "IIOP_Endpoints.pidl" -nt "IIOP_EndpointsC.h" 2> /dev/null || $(TEST_EXE) "IIOP_Endpoints.pidl" -nt "AnyTypeCode/IIOP_EndpointsA.h" 2> /dev/null || $(TEST_EXE) "IIOP_Endpoints.pidl" -nt "IIOP_EndpointsC.cpp" 2> /dev/null || $(TEST_EXE) "IIOP_Endpoints.pidl" -nt "AnyTypeCode/IIOP_EndpointsA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IIOP_EndpointsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IIOP_EndpointsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/IIOP_EndpointsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IIOP_EndpointsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/IIOP_EndpointsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IIOP_EndpointsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IIOP_EndpointsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/IIOP_EndpointsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IIOP_EndpointsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/IIOP_EndpointsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IIOP_EndpointsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IIOP_EndpointsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/IIOP_EndpointsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IIOP_EndpointsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/IIOP_EndpointsA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
IIOP_EndpointsS.h IIOP_EndpointsC.h AnyTypeCode/IIOP_EndpointsA.h IIOP_EndpointsC.cpp AnyTypeCode/IIOP_EndpointsA.cpp: IIOP_Endpoints.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci IIOP_Endpoints.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
IIOP_EndpointsS.h IIOP_EndpointsC.h AnyTypeCode/IIOP_EndpointsA.h IIOP_EndpointsC.cpp AnyTypeCode/IIOP_EndpointsA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += IOPS.h IOPC.h AnyTypeCode/IOPA.h IOPC.cpp AnyTypeCode/IOPA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "IOP.pidl" -nt "IOPS.h" 2> /dev/null || $(TEST_EXE) "IOP.pidl" -nt "IOPC.h" 2> /dev/null || $(TEST_EXE) "IOP.pidl" -nt "AnyTypeCode/IOPA.h" 2> /dev/null || $(TEST_EXE) "IOP.pidl" -nt "IOPC.cpp" 2> /dev/null || $(TEST_EXE) "IOP.pidl" -nt "AnyTypeCode/IOPA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/IOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "IOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/IOPA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/IOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "IOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/IOPA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IOPS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IOPC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/IOPA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "IOPC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/IOPA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
IOPS.h IOPC.h AnyTypeCode/IOPA.h IOPC.cpp AnyTypeCode/IOPA.cpp: IOP.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci IOP.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
IOPS.h IOPC.h AnyTypeCode/IOPA.h IOPC.cpp AnyTypeCode/IOPA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Messaging_PolicyValueS.h Messaging_PolicyValueC.h AnyTypeCode/Messaging_PolicyValueA.h Messaging_PolicyValueC.cpp AnyTypeCode/Messaging_PolicyValueA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Messaging_PolicyValue.pidl" -nt "Messaging_PolicyValueS.h" 2> /dev/null || $(TEST_EXE) "Messaging_PolicyValue.pidl" -nt "Messaging_PolicyValueC.h" 2> /dev/null || $(TEST_EXE) "Messaging_PolicyValue.pidl" -nt "AnyTypeCode/Messaging_PolicyValueA.h" 2> /dev/null || $(TEST_EXE) "Messaging_PolicyValue.pidl" -nt "Messaging_PolicyValueC.cpp" 2> /dev/null || $(TEST_EXE) "Messaging_PolicyValue.pidl" -nt "AnyTypeCode/Messaging_PolicyValueA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Messaging_PolicyValueS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Messaging_PolicyValueC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Messaging_PolicyValueA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Messaging_PolicyValueC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Messaging_PolicyValueA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Messaging_PolicyValueS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Messaging_PolicyValueC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Messaging_PolicyValueA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Messaging_PolicyValueC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Messaging_PolicyValueA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Messaging_PolicyValueS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Messaging_PolicyValueC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Messaging_PolicyValueA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Messaging_PolicyValueC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Messaging_PolicyValueA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Messaging_PolicyValueS.h Messaging_PolicyValueC.h AnyTypeCode/Messaging_PolicyValueA.h Messaging_PolicyValueC.cpp AnyTypeCode/Messaging_PolicyValueA.cpp: Messaging_PolicyValue.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci Messaging_PolicyValue.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Messaging_PolicyValueS.h Messaging_PolicyValueC.h AnyTypeCode/Messaging_PolicyValueA.h Messaging_PolicyValueC.cpp AnyTypeCode/Messaging_PolicyValueA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Messaging_SyncScopeS.h Messaging_SyncScopeC.h AnyTypeCode/Messaging_SyncScopeA.h Messaging_SyncScopeC.cpp AnyTypeCode/Messaging_SyncScopeA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Messaging_SyncScope.pidl" -nt "Messaging_SyncScopeS.h" 2> /dev/null || $(TEST_EXE) "Messaging_SyncScope.pidl" -nt "Messaging_SyncScopeC.h" 2> /dev/null || $(TEST_EXE) "Messaging_SyncScope.pidl" -nt "AnyTypeCode/Messaging_SyncScopeA.h" 2> /dev/null || $(TEST_EXE) "Messaging_SyncScope.pidl" -nt "Messaging_SyncScopeC.cpp" 2> /dev/null || $(TEST_EXE) "Messaging_SyncScope.pidl" -nt "AnyTypeCode/Messaging_SyncScopeA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Messaging_SyncScopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Messaging_SyncScopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Messaging_SyncScopeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Messaging_SyncScopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Messaging_SyncScopeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Messaging_SyncScopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Messaging_SyncScopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Messaging_SyncScopeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Messaging_SyncScopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Messaging_SyncScopeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Messaging_SyncScopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Messaging_SyncScopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Messaging_SyncScopeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Messaging_SyncScopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Messaging_SyncScopeA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Messaging_SyncScopeS.h Messaging_SyncScopeC.h AnyTypeCode/Messaging_SyncScopeA.h Messaging_SyncScopeC.cpp AnyTypeCode/Messaging_SyncScopeA.cpp: Messaging_SyncScope.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci Messaging_SyncScope.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Messaging_SyncScopeS.h Messaging_SyncScopeC.h AnyTypeCode/Messaging_SyncScopeA.h Messaging_SyncScopeC.cpp AnyTypeCode/Messaging_SyncScopeA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += ObjectIdListS.h ObjectIdListC.h AnyTypeCode/ObjectIdListA.h ObjectIdListC.cpp AnyTypeCode/ObjectIdListA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "ObjectIdList.pidl" -nt "ObjectIdListS.h" 2> /dev/null || $(TEST_EXE) "ObjectIdList.pidl" -nt "ObjectIdListC.h" 2> /dev/null || $(TEST_EXE) "ObjectIdList.pidl" -nt "AnyTypeCode/ObjectIdListA.h" 2> /dev/null || $(TEST_EXE) "ObjectIdList.pidl" -nt "ObjectIdListC.cpp" 2> /dev/null || $(TEST_EXE) "ObjectIdList.pidl" -nt "AnyTypeCode/ObjectIdListA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ObjectIdListS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ObjectIdListC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ObjectIdListA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ObjectIdListC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ObjectIdListA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ObjectIdListS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ObjectIdListC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ObjectIdListA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ObjectIdListC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ObjectIdListA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ObjectIdListS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ObjectIdListC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ObjectIdListA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ObjectIdListC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ObjectIdListA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
ObjectIdListS.h ObjectIdListC.h AnyTypeCode/ObjectIdListA.h ObjectIdListC.cpp AnyTypeCode/ObjectIdListA.cpp: ObjectIdList.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci ObjectIdList.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
ObjectIdListS.h ObjectIdListC.h AnyTypeCode/ObjectIdListA.h ObjectIdListC.cpp AnyTypeCode/ObjectIdListA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += orb_typesS.h orb_typesC.h AnyTypeCode/orb_typesA.h orb_typesC.cpp AnyTypeCode/orb_typesA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "orb_types.pidl" -nt "orb_typesS.h" 2> /dev/null || $(TEST_EXE) "orb_types.pidl" -nt "orb_typesC.h" 2> /dev/null || $(TEST_EXE) "orb_types.pidl" -nt "AnyTypeCode/orb_typesA.h" 2> /dev/null || $(TEST_EXE) "orb_types.pidl" -nt "orb_typesC.cpp" 2> /dev/null || $(TEST_EXE) "orb_types.pidl" -nt "AnyTypeCode/orb_typesA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "orb_typesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "orb_typesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/orb_typesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "orb_typesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/orb_typesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "orb_typesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "orb_typesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/orb_typesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "orb_typesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/orb_typesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "orb_typesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "orb_typesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/orb_typesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "orb_typesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/orb_typesA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
orb_typesS.h orb_typesC.h AnyTypeCode/orb_typesA.h orb_typesC.cpp AnyTypeCode/orb_typesA.cpp: orb_types.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci orb_types.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
orb_typesS.h orb_typesC.h AnyTypeCode/orb_typesA.h orb_typesC.cpp AnyTypeCode/orb_typesA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Policy_ManagerS.h Policy_ManagerC.h AnyTypeCode/Policy_ManagerA.h Policy_ManagerC.cpp AnyTypeCode/Policy_ManagerA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Policy_Manager.pidl" -nt "Policy_ManagerS.h" 2> /dev/null || $(TEST_EXE) "Policy_Manager.pidl" -nt "Policy_ManagerC.h" 2> /dev/null || $(TEST_EXE) "Policy_Manager.pidl" -nt "AnyTypeCode/Policy_ManagerA.h" 2> /dev/null || $(TEST_EXE) "Policy_Manager.pidl" -nt "Policy_ManagerC.cpp" 2> /dev/null || $(TEST_EXE) "Policy_Manager.pidl" -nt "AnyTypeCode/Policy_ManagerA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_ManagerS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_ManagerC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Policy_ManagerA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_ManagerC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Policy_ManagerA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_ManagerS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_ManagerC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Policy_ManagerA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_ManagerC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Policy_ManagerA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_ManagerS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_ManagerC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Policy_ManagerA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_ManagerC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Policy_ManagerA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Policy_ManagerS.h Policy_ManagerC.h AnyTypeCode/Policy_ManagerA.h Policy_ManagerC.cpp AnyTypeCode/Policy_ManagerA.cpp: Policy_Manager.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci Policy_Manager.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Policy_ManagerS.h Policy_ManagerC.h AnyTypeCode/Policy_ManagerA.h Policy_ManagerC.cpp AnyTypeCode/Policy_ManagerA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Policy_CurrentS.h Policy_CurrentC.h AnyTypeCode/Policy_CurrentA.h Policy_CurrentC.cpp AnyTypeCode/Policy_CurrentA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Policy_Current.pidl" -nt "Policy_CurrentS.h" 2> /dev/null || $(TEST_EXE) "Policy_Current.pidl" -nt "Policy_CurrentC.h" 2> /dev/null || $(TEST_EXE) "Policy_Current.pidl" -nt "AnyTypeCode/Policy_CurrentA.h" 2> /dev/null || $(TEST_EXE) "Policy_Current.pidl" -nt "Policy_CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "Policy_Current.pidl" -nt "AnyTypeCode/Policy_CurrentA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_CurrentS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_CurrentC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Policy_CurrentA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Policy_CurrentA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_CurrentS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_CurrentC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Policy_CurrentA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Policy_CurrentA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_CurrentS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_CurrentC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Policy_CurrentA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_CurrentC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Policy_CurrentA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Policy_CurrentS.h Policy_CurrentC.h AnyTypeCode/Policy_CurrentA.h Policy_CurrentC.cpp AnyTypeCode/Policy_CurrentA.cpp: Policy_Current.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci Policy_Current.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Policy_CurrentS.h Policy_CurrentC.h AnyTypeCode/Policy_CurrentA.h Policy_CurrentC.cpp AnyTypeCode/Policy_CurrentA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += PI_ForwardS.h PI_ForwardC.h AnyTypeCode/PI_ForwardA.h PI_ForwardC.cpp AnyTypeCode/PI_ForwardA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "PI_Forward.pidl" -nt "PI_ForwardS.h" 2> /dev/null || $(TEST_EXE) "PI_Forward.pidl" -nt "PI_ForwardC.h" 2> /dev/null || $(TEST_EXE) "PI_Forward.pidl" -nt "AnyTypeCode/PI_ForwardA.h" 2> /dev/null || $(TEST_EXE) "PI_Forward.pidl" -nt "PI_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "PI_Forward.pidl" -nt "AnyTypeCode/PI_ForwardA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PI_ForwardS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PI_ForwardC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/PI_ForwardA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PI_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/PI_ForwardA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PI_ForwardS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PI_ForwardC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/PI_ForwardA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PI_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/PI_ForwardA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PI_ForwardS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PI_ForwardC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/PI_ForwardA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PI_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/PI_ForwardA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
PI_ForwardS.h PI_ForwardC.h AnyTypeCode/PI_ForwardA.h PI_ForwardC.cpp AnyTypeCode/PI_ForwardA.cpp: PI_Forward.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci PI_Forward.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
PI_ForwardS.h PI_ForwardC.h AnyTypeCode/PI_ForwardA.h PI_ForwardC.cpp AnyTypeCode/PI_ForwardA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += PortableInterceptorS.h PortableInterceptorC.h AnyTypeCode/PortableInterceptorA.h PortableInterceptorC.cpp AnyTypeCode/PortableInterceptorA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "PortableInterceptor.pidl" -nt "PortableInterceptorS.h" 2> /dev/null || $(TEST_EXE) "PortableInterceptor.pidl" -nt "PortableInterceptorC.h" 2> /dev/null || $(TEST_EXE) "PortableInterceptor.pidl" -nt "AnyTypeCode/PortableInterceptorA.h" 2> /dev/null || $(TEST_EXE) "PortableInterceptor.pidl" -nt "PortableInterceptorC.cpp" 2> /dev/null || $(TEST_EXE) "PortableInterceptor.pidl" -nt "AnyTypeCode/PortableInterceptorA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableInterceptorS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableInterceptorC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/PortableInterceptorA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableInterceptorC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/PortableInterceptorA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableInterceptorS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableInterceptorC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/PortableInterceptorA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableInterceptorC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/PortableInterceptorA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableInterceptorS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableInterceptorC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/PortableInterceptorA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableInterceptorC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/PortableInterceptorA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
PortableInterceptorS.h PortableInterceptorC.h AnyTypeCode/PortableInterceptorA.h PortableInterceptorC.cpp AnyTypeCode/PortableInterceptorA.cpp: PortableInterceptor.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci PortableInterceptor.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
PortableInterceptorS.h PortableInterceptorC.h AnyTypeCode/PortableInterceptorA.h PortableInterceptorC.cpp AnyTypeCode/PortableInterceptorA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += ServicesS.h ServicesC.h AnyTypeCode/ServicesA.h ServicesC.cpp AnyTypeCode/ServicesA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Services.pidl" -nt "ServicesS.h" 2> /dev/null || $(TEST_EXE) "Services.pidl" -nt "ServicesC.h" 2> /dev/null || $(TEST_EXE) "Services.pidl" -nt "AnyTypeCode/ServicesA.h" 2> /dev/null || $(TEST_EXE) "Services.pidl" -nt "ServicesC.cpp" 2> /dev/null || $(TEST_EXE) "Services.pidl" -nt "AnyTypeCode/ServicesA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ServicesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ServicesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ServicesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ServicesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ServicesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ServicesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ServicesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ServicesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ServicesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ServicesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ServicesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ServicesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ServicesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ServicesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ServicesA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
ServicesS.h ServicesC.h AnyTypeCode/ServicesA.h ServicesC.cpp AnyTypeCode/ServicesA.cpp: Services.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci Services.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
ServicesS.h ServicesC.h AnyTypeCode/ServicesA.h ServicesC.cpp AnyTypeCode/ServicesA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += TAOS.h TAOC.h AnyTypeCode/TAOA.h TAOC.cpp AnyTypeCode/TAOA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "TAO.pidl" -nt "TAOS.h" 2> /dev/null || $(TEST_EXE) "TAO.pidl" -nt "TAOC.h" 2> /dev/null || $(TEST_EXE) "TAO.pidl" -nt "AnyTypeCode/TAOA.h" 2> /dev/null || $(TEST_EXE) "TAO.pidl" -nt "TAOC.cpp" 2> /dev/null || $(TEST_EXE) "TAO.pidl" -nt "AnyTypeCode/TAOA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TAOS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TAOC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/TAOA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TAOC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/TAOA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TAOS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TAOC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/TAOA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TAOC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/TAOA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TAOS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TAOC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/TAOA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TAOC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/TAOA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
TAOS.h TAOC.h AnyTypeCode/TAOA.h TAOC.cpp AnyTypeCode/TAOA.cpp: TAO.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci TAO.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
TAOS.h TAOC.h AnyTypeCode/TAOA.h TAOC.cpp AnyTypeCode/TAOA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += TimeBaseS.h TimeBaseC.h AnyTypeCode/TimeBaseA.h TimeBaseC.cpp AnyTypeCode/TimeBaseA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "TimeBase.pidl" -nt "TimeBaseS.h" 2> /dev/null || $(TEST_EXE) "TimeBase.pidl" -nt "TimeBaseC.h" 2> /dev/null || $(TEST_EXE) "TimeBase.pidl" -nt "AnyTypeCode/TimeBaseA.h" 2> /dev/null || $(TEST_EXE) "TimeBase.pidl" -nt "TimeBaseC.cpp" 2> /dev/null || $(TEST_EXE) "TimeBase.pidl" -nt "AnyTypeCode/TimeBaseA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TimeBaseS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TimeBaseC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/TimeBaseA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TimeBaseC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/TimeBaseA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TimeBaseS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TimeBaseC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/TimeBaseA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TimeBaseC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/TimeBaseA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TimeBaseS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TimeBaseC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/TimeBaseA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TimeBaseC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/TimeBaseA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
TimeBaseS.h TimeBaseC.h AnyTypeCode/TimeBaseA.h TimeBaseC.cpp AnyTypeCode/TimeBaseA.cpp: TimeBase.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci TimeBase.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
TimeBaseS.h TimeBaseC.h AnyTypeCode/TimeBaseA.h TimeBaseC.cpp AnyTypeCode/TimeBaseA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Policy_ForwardS.h Policy_ForwardC.h AnyTypeCode/Policy_ForwardA.h Policy_ForwardC.cpp AnyTypeCode/Policy_ForwardA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Policy_Forward.pidl" -nt "Policy_ForwardS.h" 2> /dev/null || $(TEST_EXE) "Policy_Forward.pidl" -nt "Policy_ForwardC.h" 2> /dev/null || $(TEST_EXE) "Policy_Forward.pidl" -nt "AnyTypeCode/Policy_ForwardA.h" 2> /dev/null || $(TEST_EXE) "Policy_Forward.pidl" -nt "Policy_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "Policy_Forward.pidl" -nt "AnyTypeCode/Policy_ForwardA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_ForwardS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_ForwardC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Policy_ForwardA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Policy_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/Policy_ForwardA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_ForwardS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_ForwardC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Policy_ForwardA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Policy_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/Policy_ForwardA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_ForwardS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_ForwardC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Policy_ForwardA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Policy_ForwardC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/Policy_ForwardA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Policy_ForwardS.h Policy_ForwardC.h AnyTypeCode/Policy_ForwardA.h Policy_ForwardC.cpp AnyTypeCode/Policy_ForwardA.cpp: Policy_Forward.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Sa Policy_Forward.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Policy_ForwardS.h Policy_ForwardC.h AnyTypeCode/Policy_ForwardA.h Policy_ForwardC.cpp AnyTypeCode/Policy_ForwardA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += ParameterModeS.h ParameterModeC.h AnyTypeCode/ParameterModeA.h ParameterModeC.cpp AnyTypeCode/ParameterModeA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "ParameterMode.pidl" -nt "ParameterModeS.h" 2> /dev/null || $(TEST_EXE) "ParameterMode.pidl" -nt "ParameterModeC.h" 2> /dev/null || $(TEST_EXE) "ParameterMode.pidl" -nt "AnyTypeCode/ParameterModeA.h" 2> /dev/null || $(TEST_EXE) "ParameterMode.pidl" -nt "ParameterModeC.cpp" 2> /dev/null || $(TEST_EXE) "ParameterMode.pidl" -nt "AnyTypeCode/ParameterModeA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ParameterModeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ParameterModeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ParameterModeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ParameterModeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ParameterModeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ParameterModeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ParameterModeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ParameterModeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ParameterModeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ParameterModeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ParameterModeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ParameterModeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ParameterModeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ParameterModeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ParameterModeA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
ParameterModeS.h ParameterModeC.h AnyTypeCode/ParameterModeA.h ParameterModeC.cpp AnyTypeCode/ParameterModeA.cpp: ParameterMode.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Sat ParameterMode.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
ParameterModeS.h ParameterModeC.h AnyTypeCode/ParameterModeA.h ParameterModeC.cpp AnyTypeCode/ParameterModeA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += BooleanSeqS.h BooleanSeqC.h AnyTypeCode/BooleanSeqA.h BooleanSeqC.cpp AnyTypeCode/BooleanSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "BooleanSeq.pidl" -nt "BooleanSeqS.h" 2> /dev/null || $(TEST_EXE) "BooleanSeq.pidl" -nt "BooleanSeqC.h" 2> /dev/null || $(TEST_EXE) "BooleanSeq.pidl" -nt "AnyTypeCode/BooleanSeqA.h" 2> /dev/null || $(TEST_EXE) "BooleanSeq.pidl" -nt "BooleanSeqC.cpp" 2> /dev/null || $(TEST_EXE) "BooleanSeq.pidl" -nt "AnyTypeCode/BooleanSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "BooleanSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "BooleanSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/BooleanSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "BooleanSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/BooleanSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "BooleanSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "BooleanSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/BooleanSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "BooleanSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/BooleanSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "BooleanSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "BooleanSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/BooleanSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "BooleanSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/BooleanSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
BooleanSeqS.h BooleanSeqC.h AnyTypeCode/BooleanSeqA.h BooleanSeqC.cpp AnyTypeCode/BooleanSeqA.cpp: BooleanSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata BooleanSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
BooleanSeqS.h BooleanSeqC.h AnyTypeCode/BooleanSeqA.h BooleanSeqC.cpp AnyTypeCode/BooleanSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += CharSeqS.h CharSeqC.h AnyTypeCode/CharSeqA.h CharSeqC.cpp AnyTypeCode/CharSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "CharSeq.pidl" -nt "CharSeqS.h" 2> /dev/null || $(TEST_EXE) "CharSeq.pidl" -nt "CharSeqC.h" 2> /dev/null || $(TEST_EXE) "CharSeq.pidl" -nt "AnyTypeCode/CharSeqA.h" 2> /dev/null || $(TEST_EXE) "CharSeq.pidl" -nt "CharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "CharSeq.pidl" -nt "AnyTypeCode/CharSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CharSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CharSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/CharSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "CharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/CharSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CharSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CharSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/CharSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "CharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/CharSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CharSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CharSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/CharSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "CharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/CharSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
CharSeqS.h CharSeqC.h AnyTypeCode/CharSeqA.h CharSeqC.cpp AnyTypeCode/CharSeqA.cpp: CharSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata CharSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
CharSeqS.h CharSeqC.h AnyTypeCode/CharSeqA.h CharSeqC.cpp AnyTypeCode/CharSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += DoubleSeqS.h DoubleSeqC.h AnyTypeCode/DoubleSeqA.h DoubleSeqC.cpp AnyTypeCode/DoubleSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "DoubleSeq.pidl" -nt "DoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "DoubleSeq.pidl" -nt "DoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "DoubleSeq.pidl" -nt "AnyTypeCode/DoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "DoubleSeq.pidl" -nt "DoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "DoubleSeq.pidl" -nt "AnyTypeCode/DoubleSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/DoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "DoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/DoubleSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/DoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "DoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/DoubleSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/DoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "DoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/DoubleSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
DoubleSeqS.h DoubleSeqC.h AnyTypeCode/DoubleSeqA.h DoubleSeqC.cpp AnyTypeCode/DoubleSeqA.cpp: DoubleSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata DoubleSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
DoubleSeqS.h DoubleSeqC.h AnyTypeCode/DoubleSeqA.h DoubleSeqC.cpp AnyTypeCode/DoubleSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += FloatSeqS.h FloatSeqC.h AnyTypeCode/FloatSeqA.h FloatSeqC.cpp AnyTypeCode/FloatSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "FloatSeq.pidl" -nt "FloatSeqS.h" 2> /dev/null || $(TEST_EXE) "FloatSeq.pidl" -nt "FloatSeqC.h" 2> /dev/null || $(TEST_EXE) "FloatSeq.pidl" -nt "AnyTypeCode/FloatSeqA.h" 2> /dev/null || $(TEST_EXE) "FloatSeq.pidl" -nt "FloatSeqC.cpp" 2> /dev/null || $(TEST_EXE) "FloatSeq.pidl" -nt "AnyTypeCode/FloatSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "FloatSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "FloatSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/FloatSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "FloatSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/FloatSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "FloatSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "FloatSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/FloatSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "FloatSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/FloatSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "FloatSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "FloatSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/FloatSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "FloatSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/FloatSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
FloatSeqS.h FloatSeqC.h AnyTypeCode/FloatSeqA.h FloatSeqC.cpp AnyTypeCode/FloatSeqA.cpp: FloatSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata FloatSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
FloatSeqS.h FloatSeqC.h AnyTypeCode/FloatSeqA.h FloatSeqC.cpp AnyTypeCode/FloatSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += LongDoubleSeqS.h LongDoubleSeqC.h AnyTypeCode/LongDoubleSeqA.h LongDoubleSeqC.cpp AnyTypeCode/LongDoubleSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "LongDoubleSeq.pidl" -nt "LongDoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "LongDoubleSeq.pidl" -nt "LongDoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "LongDoubleSeq.pidl" -nt "AnyTypeCode/LongDoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "LongDoubleSeq.pidl" -nt "LongDoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "LongDoubleSeq.pidl" -nt "AnyTypeCode/LongDoubleSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongDoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongDoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/LongDoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongDoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/LongDoubleSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongDoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongDoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/LongDoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongDoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/LongDoubleSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongDoubleSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongDoubleSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/LongDoubleSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongDoubleSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/LongDoubleSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
LongDoubleSeqS.h LongDoubleSeqC.h AnyTypeCode/LongDoubleSeqA.h LongDoubleSeqC.cpp AnyTypeCode/LongDoubleSeqA.cpp: LongDoubleSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata LongDoubleSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
LongDoubleSeqS.h LongDoubleSeqC.h AnyTypeCode/LongDoubleSeqA.h LongDoubleSeqC.cpp AnyTypeCode/LongDoubleSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += LongLongSeqS.h LongLongSeqC.h AnyTypeCode/LongLongSeqA.h LongLongSeqC.cpp AnyTypeCode/LongLongSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "LongLongSeq.pidl" -nt "LongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "LongLongSeq.pidl" -nt "LongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "LongLongSeq.pidl" -nt "AnyTypeCode/LongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "LongLongSeq.pidl" -nt "LongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "LongLongSeq.pidl" -nt "AnyTypeCode/LongLongSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/LongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/LongLongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/LongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/LongLongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/LongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/LongLongSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
LongLongSeqS.h LongLongSeqC.h AnyTypeCode/LongLongSeqA.h LongLongSeqC.cpp AnyTypeCode/LongLongSeqA.cpp: LongLongSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata LongLongSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
LongLongSeqS.h LongLongSeqC.h AnyTypeCode/LongLongSeqA.h LongLongSeqC.cpp AnyTypeCode/LongLongSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += LongSeqS.h LongSeqC.h AnyTypeCode/LongSeqA.h LongSeqC.cpp AnyTypeCode/LongSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "LongSeq.pidl" -nt "LongSeqS.h" 2> /dev/null || $(TEST_EXE) "LongSeq.pidl" -nt "LongSeqC.h" 2> /dev/null || $(TEST_EXE) "LongSeq.pidl" -nt "AnyTypeCode/LongSeqA.h" 2> /dev/null || $(TEST_EXE) "LongSeq.pidl" -nt "LongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "LongSeq.pidl" -nt "AnyTypeCode/LongSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/LongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "LongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/LongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/LongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "LongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/LongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/LongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "LongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/LongSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
LongSeqS.h LongSeqC.h AnyTypeCode/LongSeqA.h LongSeqC.cpp AnyTypeCode/LongSeqA.cpp: LongSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata LongSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
LongSeqS.h LongSeqC.h AnyTypeCode/LongSeqA.h LongSeqC.cpp AnyTypeCode/LongSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += OctetSeqS.h OctetSeqC.h AnyTypeCode/OctetSeqA.h OctetSeqC.cpp AnyTypeCode/OctetSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "OctetSeq.pidl" -nt "OctetSeqS.h" 2> /dev/null || $(TEST_EXE) "OctetSeq.pidl" -nt "OctetSeqC.h" 2> /dev/null || $(TEST_EXE) "OctetSeq.pidl" -nt "AnyTypeCode/OctetSeqA.h" 2> /dev/null || $(TEST_EXE) "OctetSeq.pidl" -nt "OctetSeqC.cpp" 2> /dev/null || $(TEST_EXE) "OctetSeq.pidl" -nt "AnyTypeCode/OctetSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "OctetSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "OctetSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/OctetSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "OctetSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/OctetSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "OctetSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "OctetSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/OctetSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "OctetSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/OctetSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "OctetSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "OctetSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/OctetSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "OctetSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/OctetSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
OctetSeqS.h OctetSeqC.h AnyTypeCode/OctetSeqA.h OctetSeqC.cpp AnyTypeCode/OctetSeqA.cpp: OctetSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata OctetSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
OctetSeqS.h OctetSeqC.h AnyTypeCode/OctetSeqA.h OctetSeqC.cpp AnyTypeCode/OctetSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += ShortSeqS.h ShortSeqC.h AnyTypeCode/ShortSeqA.h ShortSeqC.cpp AnyTypeCode/ShortSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "ShortSeq.pidl" -nt "ShortSeqS.h" 2> /dev/null || $(TEST_EXE) "ShortSeq.pidl" -nt "ShortSeqC.h" 2> /dev/null || $(TEST_EXE) "ShortSeq.pidl" -nt "AnyTypeCode/ShortSeqA.h" 2> /dev/null || $(TEST_EXE) "ShortSeq.pidl" -nt "ShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "ShortSeq.pidl" -nt "AnyTypeCode/ShortSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ShortSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ShortSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ShortSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ShortSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ShortSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ShortSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ShortSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ShortSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ShortSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ShortSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ShortSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ShortSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
ShortSeqS.h ShortSeqC.h AnyTypeCode/ShortSeqA.h ShortSeqC.cpp AnyTypeCode/ShortSeqA.cpp: ShortSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata ShortSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
ShortSeqS.h ShortSeqC.h AnyTypeCode/ShortSeqA.h ShortSeqC.cpp AnyTypeCode/ShortSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += StringSeqS.h StringSeqC.h AnyTypeCode/StringSeqA.h StringSeqC.cpp AnyTypeCode/StringSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "StringSeq.pidl" -nt "StringSeqS.h" 2> /dev/null || $(TEST_EXE) "StringSeq.pidl" -nt "StringSeqC.h" 2> /dev/null || $(TEST_EXE) "StringSeq.pidl" -nt "AnyTypeCode/StringSeqA.h" 2> /dev/null || $(TEST_EXE) "StringSeq.pidl" -nt "StringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "StringSeq.pidl" -nt "AnyTypeCode/StringSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "StringSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "StringSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/StringSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "StringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/StringSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "StringSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "StringSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/StringSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "StringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/StringSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "StringSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "StringSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/StringSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "StringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/StringSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
StringSeqS.h StringSeqC.h AnyTypeCode/StringSeqA.h StringSeqC.cpp AnyTypeCode/StringSeqA.cpp: StringSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata StringSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
StringSeqS.h StringSeqC.h AnyTypeCode/StringSeqA.h StringSeqC.cpp AnyTypeCode/StringSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += ULongLongSeqS.h ULongLongSeqC.h AnyTypeCode/ULongLongSeqA.h ULongLongSeqC.cpp AnyTypeCode/ULongLongSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "ULongLongSeq.pidl" -nt "ULongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "ULongLongSeq.pidl" -nt "ULongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "ULongLongSeq.pidl" -nt "AnyTypeCode/ULongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "ULongLongSeq.pidl" -nt "ULongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "ULongLongSeq.pidl" -nt "AnyTypeCode/ULongLongSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ULongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ULongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ULongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ULongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ULongLongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ULongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ULongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ULongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ULongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ULongLongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ULongLongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ULongLongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ULongLongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ULongLongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ULongLongSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
ULongLongSeqS.h ULongLongSeqC.h AnyTypeCode/ULongLongSeqA.h ULongLongSeqC.cpp AnyTypeCode/ULongLongSeqA.cpp: ULongLongSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata ULongLongSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
ULongLongSeqS.h ULongLongSeqC.h AnyTypeCode/ULongLongSeqA.h ULongLongSeqC.cpp AnyTypeCode/ULongLongSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += ULongSeqS.h ULongSeqC.h AnyTypeCode/ULongSeqA.h ULongSeqC.cpp AnyTypeCode/ULongSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "ULongSeq.pidl" -nt "ULongSeqS.h" 2> /dev/null || $(TEST_EXE) "ULongSeq.pidl" -nt "ULongSeqC.h" 2> /dev/null || $(TEST_EXE) "ULongSeq.pidl" -nt "AnyTypeCode/ULongSeqA.h" 2> /dev/null || $(TEST_EXE) "ULongSeq.pidl" -nt "ULongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "ULongSeq.pidl" -nt "AnyTypeCode/ULongSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ULongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ULongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ULongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "ULongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/ULongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ULongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ULongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ULongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "ULongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/ULongSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ULongSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ULongSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ULongSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "ULongSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/ULongSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
ULongSeqS.h ULongSeqC.h AnyTypeCode/ULongSeqA.h ULongSeqC.cpp AnyTypeCode/ULongSeqA.cpp: ULongSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata ULongSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
ULongSeqS.h ULongSeqC.h AnyTypeCode/ULongSeqA.h ULongSeqC.cpp AnyTypeCode/ULongSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += UShortSeqS.h UShortSeqC.h AnyTypeCode/UShortSeqA.h UShortSeqC.cpp AnyTypeCode/UShortSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "UShortSeq.pidl" -nt "UShortSeqS.h" 2> /dev/null || $(TEST_EXE) "UShortSeq.pidl" -nt "UShortSeqC.h" 2> /dev/null || $(TEST_EXE) "UShortSeq.pidl" -nt "AnyTypeCode/UShortSeqA.h" 2> /dev/null || $(TEST_EXE) "UShortSeq.pidl" -nt "UShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "UShortSeq.pidl" -nt "AnyTypeCode/UShortSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "UShortSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "UShortSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/UShortSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "UShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/UShortSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "UShortSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "UShortSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/UShortSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "UShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/UShortSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "UShortSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "UShortSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/UShortSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "UShortSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/UShortSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
UShortSeqS.h UShortSeqC.h AnyTypeCode/UShortSeqA.h UShortSeqC.cpp AnyTypeCode/UShortSeqA.cpp: UShortSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata UShortSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
UShortSeqS.h UShortSeqC.h AnyTypeCode/UShortSeqA.h UShortSeqC.cpp AnyTypeCode/UShortSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += WCharSeqS.h WCharSeqC.h AnyTypeCode/WCharSeqA.h WCharSeqC.cpp AnyTypeCode/WCharSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "WCharSeq.pidl" -nt "WCharSeqS.h" 2> /dev/null || $(TEST_EXE) "WCharSeq.pidl" -nt "WCharSeqC.h" 2> /dev/null || $(TEST_EXE) "WCharSeq.pidl" -nt "AnyTypeCode/WCharSeqA.h" 2> /dev/null || $(TEST_EXE) "WCharSeq.pidl" -nt "WCharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "WCharSeq.pidl" -nt "AnyTypeCode/WCharSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "WCharSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "WCharSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/WCharSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "WCharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/WCharSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "WCharSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "WCharSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/WCharSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "WCharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/WCharSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "WCharSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "WCharSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/WCharSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "WCharSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/WCharSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
WCharSeqS.h WCharSeqC.h AnyTypeCode/WCharSeqA.h WCharSeqC.cpp AnyTypeCode/WCharSeqA.cpp: WCharSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata WCharSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
WCharSeqS.h WCharSeqC.h AnyTypeCode/WCharSeqA.h WCharSeqC.cpp AnyTypeCode/WCharSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += WStringSeqS.h WStringSeqC.h AnyTypeCode/WStringSeqA.h WStringSeqC.cpp AnyTypeCode/WStringSeqA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "WStringSeq.pidl" -nt "WStringSeqS.h" 2> /dev/null || $(TEST_EXE) "WStringSeq.pidl" -nt "WStringSeqC.h" 2> /dev/null || $(TEST_EXE) "WStringSeq.pidl" -nt "AnyTypeCode/WStringSeqA.h" 2> /dev/null || $(TEST_EXE) "WStringSeq.pidl" -nt "WStringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "WStringSeq.pidl" -nt "AnyTypeCode/WStringSeqA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "WStringSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "WStringSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/WStringSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "WStringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/WStringSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "WStringSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "WStringSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/WStringSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "WStringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/WStringSeqA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "WStringSeqS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "WStringSeqC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/WStringSeqA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "WStringSeqC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/WStringSeqA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
WStringSeqS.h WStringSeqC.h AnyTypeCode/WStringSeqA.h WStringSeqC.cpp AnyTypeCode/WStringSeqA.cpp: WStringSeq.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -SS -Sorb -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -Sci -Gse -Gata WStringSeq.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
WStringSeqS.h WStringSeqC.h AnyTypeCode/WStringSeqA.h WStringSeqC.cpp AnyTypeCode/WStringSeqA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += PolicyC.h PortableServer/PolicyS.h PolicyC.inl PolicyC.cpp PortableServer/PolicyS.cpp PortableServer/PolicyS_T.cpp PortableServer/PolicyS_T.h AnyTypeCode/PolicyA.h AnyTypeCode/PolicyA.cpp
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Policy.pidl" -nt "PolicyC.h" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "PortableServer/PolicyS.h" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "PolicyC.inl" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "PolicyC.cpp" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "PortableServer/PolicyS.cpp" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "PortableServer/PolicyS_T.cpp" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "PortableServer/PolicyS_T.h" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "AnyTypeCode/PolicyA.h" 2> /dev/null || $(TEST_EXE) "Policy.pidl" -nt "AnyTypeCode/PolicyA.cpp" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PolicyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableServer/PolicyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PolicyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PolicyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableServer/PolicyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableServer/PolicyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PortableServer/PolicyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/PolicyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "AnyTypeCode/PolicyA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PolicyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableServer/PolicyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PolicyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PolicyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableServer/PolicyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableServer/PolicyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PortableServer/PolicyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/PolicyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "AnyTypeCode/PolicyA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PolicyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableServer/PolicyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PolicyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PolicyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableServer/PolicyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableServer/PolicyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PortableServer/PolicyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/PolicyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "AnyTypeCode/PolicyA.cpp" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
PolicyC.h PortableServer/PolicyS.h PolicyC.inl PolicyC.cpp PortableServer/PolicyS.cpp PortableServer/PolicyS_T.cpp PortableServer/PolicyS_T.h AnyTypeCode/PolicyA.h AnyTypeCode/PolicyA.cpp: Policy.pidl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -DGEN_IDL_MAKE_DEPS -Wb,versioning_begin=TAO_BEGIN_VERSIONED_NAMESPACE_DECL -Wb,versioning_end=TAO_END_VERSIONED_NAMESPACE_DECL -GA -Gp -Gd -oA AnyTypeCode -Wb,export_macro=TAO_Export -Wb,export_include=tao/TAO_Export.h -Wb,anyop_export_macro=TAO_AnyTypeCode_Export -Wb,anyop_export_include=tao/AnyTypeCode/TAO_AnyTypeCode_Export.h -GT -oS PortableServer -Gd -Wb,safe_include=tao/PolicyC.h -Wb,skel_export_macro=TAO_PortableServer_Export -Wb,skel_export_include=tao/PortableServer/portableserver_export.h Policy.pidl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
PolicyC.h PortableServer/PolicyS.h PolicyC.inl PolicyC.cpp PortableServer/PolicyS.cpp PortableServer/PolicyS_T.cpp PortableServer/PolicyS_T.h AnyTypeCode/PolicyA.h AnyTypeCode/PolicyA.cpp: $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

ifneq ($(GENERATED_DIRTY),)
.PRECIOUS: $(GENERATED_DIRTY)
all: $(GENERATED_DIRTY)
endif

ADDITIONAL_IDL_TARGETS += GIOP$(IDL_CLIENT_HDR_EXT) CONV_FRAME$(IDL_CLIENT_HDR_EXT) Current$(IDL_CLIENT_HDR_EXT) IIOP$(IDL_CLIENT_HDR_EXT) IIOP_Endpoints$(IDL_CLIENT_HDR_EXT) IOP$(IDL_CLIENT_HDR_EXT) Messaging_PolicyValue$(IDL_CLIENT_HDR_EXT) Messaging_SyncScope$(IDL_CLIENT_HDR_EXT) ObjectIdList$(IDL_CLIENT_HDR_EXT) orb_types$(IDL_CLIENT_HDR_EXT) Policy_Manager$(IDL_CLIENT_HDR_EXT) Policy_Current$(IDL_CLIENT_HDR_EXT) PI_Forward$(IDL_CLIENT_HDR_EXT) PortableInterceptor$(IDL_CLIENT_HDR_EXT) Services$(IDL_CLIENT_HDR_EXT) TAO$(IDL_CLIENT_HDR_EXT) TimeBase$(IDL_CLIENT_HDR_EXT) Policy_Forward$(IDL_CLIENT_HDR_EXT) ParameterMode$(IDL_CLIENT_HDR_EXT) BooleanSeq$(IDL_CLIENT_HDR_EXT) CharSeq$(IDL_CLIENT_HDR_EXT) DoubleSeq$(IDL_CLIENT_HDR_EXT) FloatSeq$(IDL_CLIENT_HDR_EXT) LongDoubleSeq$(IDL_CLIENT_HDR_EXT) LongLongSeq$(IDL_CLIENT_HDR_EXT) LongSeq$(IDL_CLIENT_HDR_EXT) OctetSeq$(IDL_CLIENT_HDR_EXT) ShortSeq$(IDL_CLIENT_HDR_EXT) StringSeq$(IDL_CLIENT_HDR_EXT) ULongLongSeq$(IDL_CLIENT_HDR_EXT) ULongSeq$(IDL_CLIENT_HDR_EXT) UShortSeq$(IDL_CLIENT_HDR_EXT) WCharSeq$(IDL_CLIENT_HDR_EXT) WStringSeq$(IDL_CLIENT_HDR_EXT) Policy$(IDL_CLIENT_HDR_EXT)
idl_stubs: $(ADDITIONAL_IDL_TARGETS)

incremental_depend_idl::
	@$(RM) $(IDL_DEPENDENCY_FILE1)_idl.old
	@cp $(IDL_DEPENDENCY_FILE1) $(IDL_DEPENDENCY_FILE1)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE1) \
	$(IDL_DEPS_FLAGS1) -t gnuidl -DMAKEDEPEND $(IDL_DEPS1)
	@if cmp -s $(IDL_DEPENDENCY_FILE1) $(IDL_DEPENDENCY_FILE1)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS1)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS1)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE1)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE2)_idl.old
	@cp $(IDL_DEPENDENCY_FILE2) $(IDL_DEPENDENCY_FILE2)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE2) \
	$(IDL_DEPS_FLAGS2) -t gnuidl -DMAKEDEPEND $(IDL_DEPS2)
	@if cmp -s $(IDL_DEPENDENCY_FILE2) $(IDL_DEPENDENCY_FILE2)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS2)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS2)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE2)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE3)_idl.old
	@cp $(IDL_DEPENDENCY_FILE3) $(IDL_DEPENDENCY_FILE3)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE3) \
	$(IDL_DEPS_FLAGS3) -t gnuidl -DMAKEDEPEND $(IDL_DEPS3)
	@if cmp -s $(IDL_DEPENDENCY_FILE3) $(IDL_DEPENDENCY_FILE3)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS3)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS3)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE3)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE4)_idl.old
	@cp $(IDL_DEPENDENCY_FILE4) $(IDL_DEPENDENCY_FILE4)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE4) \
	$(IDL_DEPS_FLAGS4) -t gnuidl -DMAKEDEPEND $(IDL_DEPS4)
	@if cmp -s $(IDL_DEPENDENCY_FILE4) $(IDL_DEPENDENCY_FILE4)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS4)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS4)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE4)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE5)_idl.old
	@cp $(IDL_DEPENDENCY_FILE5) $(IDL_DEPENDENCY_FILE5)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE5) \
	$(IDL_DEPS_FLAGS5) -t gnuidl -DMAKEDEPEND $(IDL_DEPS5)
	@if cmp -s $(IDL_DEPENDENCY_FILE5) $(IDL_DEPENDENCY_FILE5)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS5)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS5)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE5)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE6)_idl.old
	@cp $(IDL_DEPENDENCY_FILE6) $(IDL_DEPENDENCY_FILE6)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE6) \
	$(IDL_DEPS_FLAGS6) -t gnuidl -DMAKEDEPEND $(IDL_DEPS6)
	@if cmp -s $(IDL_DEPENDENCY_FILE6) $(IDL_DEPENDENCY_FILE6)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS6)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS6)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE6)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE7)_idl.old
	@cp $(IDL_DEPENDENCY_FILE7) $(IDL_DEPENDENCY_FILE7)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE7) \
	$(IDL_DEPS_FLAGS7) -t gnuidl -DMAKEDEPEND $(IDL_DEPS7)
	@if cmp -s $(IDL_DEPENDENCY_FILE7) $(IDL_DEPENDENCY_FILE7)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS7)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS7)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE7)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE8)_idl.old
	@cp $(IDL_DEPENDENCY_FILE8) $(IDL_DEPENDENCY_FILE8)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE8) \
	$(IDL_DEPS_FLAGS8) -t gnuidl -DMAKEDEPEND $(IDL_DEPS8)
	@if cmp -s $(IDL_DEPENDENCY_FILE8) $(IDL_DEPENDENCY_FILE8)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS8)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS8)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE8)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE9)_idl.old
	@cp $(IDL_DEPENDENCY_FILE9) $(IDL_DEPENDENCY_FILE9)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE9) \
	$(IDL_DEPS_FLAGS9) -t gnuidl -DMAKEDEPEND $(IDL_DEPS9)
	@if cmp -s $(IDL_DEPENDENCY_FILE9) $(IDL_DEPENDENCY_FILE9)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS9)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS9)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE9)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE10)_idl.old
	@cp $(IDL_DEPENDENCY_FILE10) $(IDL_DEPENDENCY_FILE10)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE10) \
	$(IDL_DEPS_FLAGS10) -t gnuidl -DMAKEDEPEND $(IDL_DEPS10)
	@if cmp -s $(IDL_DEPENDENCY_FILE10) $(IDL_DEPENDENCY_FILE10)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS10)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS10)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE10)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE11)_idl.old
	@cp $(IDL_DEPENDENCY_FILE11) $(IDL_DEPENDENCY_FILE11)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE11) \
	$(IDL_DEPS_FLAGS11) -t gnuidl -DMAKEDEPEND $(IDL_DEPS11)
	@if cmp -s $(IDL_DEPENDENCY_FILE11) $(IDL_DEPENDENCY_FILE11)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS11)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS11)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE11)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE12)_idl.old
	@cp $(IDL_DEPENDENCY_FILE12) $(IDL_DEPENDENCY_FILE12)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE12) \
	$(IDL_DEPS_FLAGS12) -t gnuidl -DMAKEDEPEND $(IDL_DEPS12)
	@if cmp -s $(IDL_DEPENDENCY_FILE12) $(IDL_DEPENDENCY_FILE12)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS12)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS12)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE12)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE13)_idl.old
	@cp $(IDL_DEPENDENCY_FILE13) $(IDL_DEPENDENCY_FILE13)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE13) \
	$(IDL_DEPS_FLAGS13) -t gnuidl -DMAKEDEPEND $(IDL_DEPS13)
	@if cmp -s $(IDL_DEPENDENCY_FILE13) $(IDL_DEPENDENCY_FILE13)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS13)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS13)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE13)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE14)_idl.old
	@cp $(IDL_DEPENDENCY_FILE14) $(IDL_DEPENDENCY_FILE14)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE14) \
	$(IDL_DEPS_FLAGS14) -t gnuidl -DMAKEDEPEND $(IDL_DEPS14)
	@if cmp -s $(IDL_DEPENDENCY_FILE14) $(IDL_DEPENDENCY_FILE14)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS14)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS14)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE14)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE15)_idl.old
	@cp $(IDL_DEPENDENCY_FILE15) $(IDL_DEPENDENCY_FILE15)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE15) \
	$(IDL_DEPS_FLAGS15) -t gnuidl -DMAKEDEPEND $(IDL_DEPS15)
	@if cmp -s $(IDL_DEPENDENCY_FILE15) $(IDL_DEPENDENCY_FILE15)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS15)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS15)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE15)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE16)_idl.old
	@cp $(IDL_DEPENDENCY_FILE16) $(IDL_DEPENDENCY_FILE16)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE16) \
	$(IDL_DEPS_FLAGS16) -t gnuidl -DMAKEDEPEND $(IDL_DEPS16)
	@if cmp -s $(IDL_DEPENDENCY_FILE16) $(IDL_DEPENDENCY_FILE16)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS16)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS16)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE16)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE17)_idl.old
	@cp $(IDL_DEPENDENCY_FILE17) $(IDL_DEPENDENCY_FILE17)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE17) \
	$(IDL_DEPS_FLAGS17) -t gnuidl -DMAKEDEPEND $(IDL_DEPS17)
	@if cmp -s $(IDL_DEPENDENCY_FILE17) $(IDL_DEPENDENCY_FILE17)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS17)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS17)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE17)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE18)_idl.old
	@cp $(IDL_DEPENDENCY_FILE18) $(IDL_DEPENDENCY_FILE18)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE18) \
	$(IDL_DEPS_FLAGS18) -t gnuidl -DMAKEDEPEND $(IDL_DEPS18)
	@if cmp -s $(IDL_DEPENDENCY_FILE18) $(IDL_DEPENDENCY_FILE18)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS18)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS18)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE18)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE19)_idl.old
	@cp $(IDL_DEPENDENCY_FILE19) $(IDL_DEPENDENCY_FILE19)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE19) \
	$(IDL_DEPS_FLAGS19) -t gnuidl -DMAKEDEPEND $(IDL_DEPS19)
	@if cmp -s $(IDL_DEPENDENCY_FILE19) $(IDL_DEPENDENCY_FILE19)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS19)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS19)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE19)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE20)_idl.old
	@cp $(IDL_DEPENDENCY_FILE20) $(IDL_DEPENDENCY_FILE20)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE20) \
	$(IDL_DEPS_FLAGS20) -t gnuidl -DMAKEDEPEND $(IDL_DEPS20)
	@if cmp -s $(IDL_DEPENDENCY_FILE20) $(IDL_DEPENDENCY_FILE20)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS20)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS20)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE20)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE21)_idl.old
	@cp $(IDL_DEPENDENCY_FILE21) $(IDL_DEPENDENCY_FILE21)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE21) \
	$(IDL_DEPS_FLAGS21) -t gnuidl -DMAKEDEPEND $(IDL_DEPS21)
	@if cmp -s $(IDL_DEPENDENCY_FILE21) $(IDL_DEPENDENCY_FILE21)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS21)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS21)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE21)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE22)_idl.old
	@cp $(IDL_DEPENDENCY_FILE22) $(IDL_DEPENDENCY_FILE22)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE22) \
	$(IDL_DEPS_FLAGS22) -t gnuidl -DMAKEDEPEND $(IDL_DEPS22)
	@if cmp -s $(IDL_DEPENDENCY_FILE22) $(IDL_DEPENDENCY_FILE22)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS22)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS22)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE22)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE23)_idl.old
	@cp $(IDL_DEPENDENCY_FILE23) $(IDL_DEPENDENCY_FILE23)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE23) \
	$(IDL_DEPS_FLAGS23) -t gnuidl -DMAKEDEPEND $(IDL_DEPS23)
	@if cmp -s $(IDL_DEPENDENCY_FILE23) $(IDL_DEPENDENCY_FILE23)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS23)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS23)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE23)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE24)_idl.old
	@cp $(IDL_DEPENDENCY_FILE24) $(IDL_DEPENDENCY_FILE24)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE24) \
	$(IDL_DEPS_FLAGS24) -t gnuidl -DMAKEDEPEND $(IDL_DEPS24)
	@if cmp -s $(IDL_DEPENDENCY_FILE24) $(IDL_DEPENDENCY_FILE24)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS24)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS24)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE24)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE25)_idl.old
	@cp $(IDL_DEPENDENCY_FILE25) $(IDL_DEPENDENCY_FILE25)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE25) \
	$(IDL_DEPS_FLAGS25) -t gnuidl -DMAKEDEPEND $(IDL_DEPS25)
	@if cmp -s $(IDL_DEPENDENCY_FILE25) $(IDL_DEPENDENCY_FILE25)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS25)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS25)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE25)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE26)_idl.old
	@cp $(IDL_DEPENDENCY_FILE26) $(IDL_DEPENDENCY_FILE26)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE26) \
	$(IDL_DEPS_FLAGS26) -t gnuidl -DMAKEDEPEND $(IDL_DEPS26)
	@if cmp -s $(IDL_DEPENDENCY_FILE26) $(IDL_DEPENDENCY_FILE26)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS26)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS26)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE26)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE27)_idl.old
	@cp $(IDL_DEPENDENCY_FILE27) $(IDL_DEPENDENCY_FILE27)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE27) \
	$(IDL_DEPS_FLAGS27) -t gnuidl -DMAKEDEPEND $(IDL_DEPS27)
	@if cmp -s $(IDL_DEPENDENCY_FILE27) $(IDL_DEPENDENCY_FILE27)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS27)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS27)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE27)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE28)_idl.old
	@cp $(IDL_DEPENDENCY_FILE28) $(IDL_DEPENDENCY_FILE28)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE28) \
	$(IDL_DEPS_FLAGS28) -t gnuidl -DMAKEDEPEND $(IDL_DEPS28)
	@if cmp -s $(IDL_DEPENDENCY_FILE28) $(IDL_DEPENDENCY_FILE28)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS28)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS28)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE28)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE29)_idl.old
	@cp $(IDL_DEPENDENCY_FILE29) $(IDL_DEPENDENCY_FILE29)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE29) \
	$(IDL_DEPS_FLAGS29) -t gnuidl -DMAKEDEPEND $(IDL_DEPS29)
	@if cmp -s $(IDL_DEPENDENCY_FILE29) $(IDL_DEPENDENCY_FILE29)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS29)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS29)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE29)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE30)_idl.old
	@cp $(IDL_DEPENDENCY_FILE30) $(IDL_DEPENDENCY_FILE30)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE30) \
	$(IDL_DEPS_FLAGS30) -t gnuidl -DMAKEDEPEND $(IDL_DEPS30)
	@if cmp -s $(IDL_DEPENDENCY_FILE30) $(IDL_DEPENDENCY_FILE30)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS30)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS30)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE30)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE31)_idl.old
	@cp $(IDL_DEPENDENCY_FILE31) $(IDL_DEPENDENCY_FILE31)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE31) \
	$(IDL_DEPS_FLAGS31) -t gnuidl -DMAKEDEPEND $(IDL_DEPS31)
	@if cmp -s $(IDL_DEPENDENCY_FILE31) $(IDL_DEPENDENCY_FILE31)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS31)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS31)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE31)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE32)_idl.old
	@cp $(IDL_DEPENDENCY_FILE32) $(IDL_DEPENDENCY_FILE32)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE32) \
	$(IDL_DEPS_FLAGS32) -t gnuidl -DMAKEDEPEND $(IDL_DEPS32)
	@if cmp -s $(IDL_DEPENDENCY_FILE32) $(IDL_DEPENDENCY_FILE32)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS32)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS32)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE32)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE33)_idl.old
	@cp $(IDL_DEPENDENCY_FILE33) $(IDL_DEPENDENCY_FILE33)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE33) \
	$(IDL_DEPS_FLAGS33) -t gnuidl -DMAKEDEPEND $(IDL_DEPS33)
	@if cmp -s $(IDL_DEPENDENCY_FILE33) $(IDL_DEPENDENCY_FILE33)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS33)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS33)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE33)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE34)_idl.old
	@cp $(IDL_DEPENDENCY_FILE34) $(IDL_DEPENDENCY_FILE34)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE34) \
	$(IDL_DEPS_FLAGS34) -t gnuidl -DMAKEDEPEND $(IDL_DEPS34)
	@if cmp -s $(IDL_DEPENDENCY_FILE34) $(IDL_DEPENDENCY_FILE34)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS34)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS34)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE34)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE35)_idl.old
	@cp $(IDL_DEPENDENCY_FILE35) $(IDL_DEPENDENCY_FILE35)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE35) \
	$(IDL_DEPS_FLAGS35) -t gnuidl -DMAKEDEPEND $(IDL_DEPS35)
	@if cmp -s $(IDL_DEPENDENCY_FILE35) $(IDL_DEPENDENCY_FILE35)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS35)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS35)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE35)_idl.old ;

realclean: clean
ifneq ($(GENERATED_DIRTY),)
	-$(RM) -r $(GENERATED_DIRTY)
endif

__prebuild__:
	@-:


.PHONY: install
install: all
INSTALL_LIB ?= lib
ifneq ($(INSTALL_PREFIX),)
ifneq ($(install_rpath),0)
LD_RPATH ?= -Wl,-rpath,
LDFLAGS += $(LD_RPATH)$(INSTALL_PREFIX)/$(INSTALL_LIB) $(LD_RPATH_FLAGS)
endif
endif

PRJINST_OPTIONS ?=
INST_DIR ?= /$(notdir $(PWD))
COMMA = ,
SPACE = $(should_be_unset) $(should_be_unset)
INSTALLER ?= $(MPC_ROOT)/prj_install.pl
CUSTOM_INST_TAGS = $(sort pidlinstallwithoutbuilding_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files idl_files )

INST_TAGS = $(CUSTOM_INST_TAGS)
INST_LOCATIONS = $(foreach tag,$(INST_TAGS),-b $(tag)=include$(INST_DIR))

DATA_INST_TAGS = 
INST_LOCATIONS += $(if $(DATA_INST_TAGS),-x installdata_files -b installdata_files=share$(INST_DIR))
INST_TAGS := $(INST_TAGS)$(if $(DATA_INST_TAGS), $(DATA_INST_TAGS))

ifeq ($(INSTALLER),/prj_install.pl)
INSTALLER = $(ACE_ROOT)/MPC/prj_install.pl
endif

ifeq ($(LIBCHECK),1)
install:
ifeq ($(INST_TAGS),)
	@echo Nothing to install.
else
ifeq ($(INSTALL_PREFIX),)
	@echo The variable INSTALL_PREFIX must be set to install.
	@echo If binaries are already built and you want to use RPATH,
	@echo they must be rebuilt after changing INSTALL_PREFIX.
	@false
else
	perl -ne'if (/^#END MPC-Generated Install Info/) {exit 0}' \
	  -e'elsif (/^#BEGIN MPC-Generated Install Info/) {$$ok=1}' \
	  -e'elsif ($$ok && s/^#//) {print}' $(MAKEFILE) | \
	$(INSTALLER) -i -s $(subst $(SPACE),$(COMMA),$(INST_TAGS)) \
	  $(INST_LOCATIONS) $(if $(ARCH),-d $(ARCH)) $(PRJINST_OPTIONS) \
	  $(DESTDIR)$(INSTALL_PREFIX)
endif
endif
endif

#BEGIN MPC-Generated Install Info
#idl_files:
#GIOP.pidl
#CONV_FRAME.pidl
#Current.pidl
#IIOP.pidl
#IIOP_Endpoints.pidl
#IOP.pidl
#Messaging_PolicyValue.pidl
#Messaging_SyncScope.pidl
#ObjectIdList.pidl
#orb_types.pidl
#Policy_Manager.pidl
#Policy_Current.pidl
#PI_Forward.pidl
#PortableInterceptor.pidl
#Services.pidl
#TAO.pidl
#TimeBase.pidl
#Policy_Forward.pidl
#ParameterMode.pidl
#BooleanSeq.pidl
#CharSeq.pidl
#DoubleSeq.pidl
#FloatSeq.pidl
#LongDoubleSeq.pidl
#LongLongSeq.pidl
#LongSeq.pidl
#OctetSeq.pidl
#ShortSeq.pidl
#StringSeq.pidl
#ULongLongSeq.pidl
#ULongSeq.pidl
#UShortSeq.pidl
#WCharSeq.pidl
#WStringSeq.pidl
#Policy.pidl
#
#pidlinstallwithoutbuilding_files:
#InterfaceDef.pidl
#InvalidName.pidl
#Object_Key.pidl
#Typecode_types.pidl
#WrongTransaction.pidl
#orb.idl
#
#build_files:
#tao.mpc
#extra_core.mpb
#tao.mwc
#

#END MPC-Generated Install Info

