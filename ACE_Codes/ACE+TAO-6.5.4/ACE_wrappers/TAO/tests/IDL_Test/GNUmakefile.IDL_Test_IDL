# -*- Makefile -*-
#----------------------------------------------------------------------------
#       GNU Makefile
#
# @file GNUmakefile.IDL_Test_IDL
#
# This file was automatically generated by MPC.  Any changes made directly to
# this file will be lost the next time it is generated.
#
#----------------------------------------------------------------------------
MAKEFILE         = GNUmakefile.IDL_Test_IDL
DEPENDENCY_FILE  = .depend.IDL_Test_IDL

IDL_DEPENDENCY_FILE1 = .depend.IDL_Test_IDL_Idl1
IDL_DEPENDENCY_FILE2 = .depend.IDL_Test_IDL_Idl2
IDL_DEPENDENCY_FILE3 = .depend.IDL_Test_IDL_Idl3
IDL_DEPENDENCY_FILE4 = .depend.IDL_Test_IDL_Idl4
IDL_DEPENDENCY_FILE5 = .depend.IDL_Test_IDL_Idl5
IDL_DEPENDENCY_FILE6 = .depend.IDL_Test_IDL_Idl6
IDL_DEPENDENCY_FILE7 = .depend.IDL_Test_IDL_Idl7
IDL_DEPENDENCY_FILE8 = .depend.IDL_Test_IDL_Idl8
IDL_DEPENDENCY_FILE9 = .depend.IDL_Test_IDL_Idl9
IDL_DEPENDENCY_FILE10 = .depend.IDL_Test_IDL_Idl10
IDL_DEPENDENCY_FILE11 = .depend.IDL_Test_IDL_Idl11
IDL_DEPENDENCY_FILE12 = .depend.IDL_Test_IDL_Idl12
IDL_DEPENDENCY_FILE13 = .depend.IDL_Test_IDL_Idl13
IDL_DEPENDENCY_FILE14 = .depend.IDL_Test_IDL_Idl14
IDL_DEPENDENCY_FILE15 = .depend.IDL_Test_IDL_Idl15
IDL_DEPENDENCY_FILE16 = .depend.IDL_Test_IDL_Idl16
IDL_DEPENDENCY_FILE17 = .depend.IDL_Test_IDL_Idl17
IDL_DEPENDENCY_FILE18 = .depend.IDL_Test_IDL_Idl18
IDL_DEPENDENCY_FILE19 = .depend.IDL_Test_IDL_Idl19
IDL_DEPENDENCY_FILE20 = .depend.IDL_Test_IDL_Idl20
IDL_DEPENDENCY_FILE21 = .depend.IDL_Test_IDL_Idl21
IDL_DEPENDENCY_FILE22 = .depend.IDL_Test_IDL_Idl22
IDL_DEPENDENCY_FILE23 = .depend.IDL_Test_IDL_Idl23
IDL_DEPENDENCY_FILE24 = .depend.IDL_Test_IDL_Idl24
IDL_DEPENDENCY_FILE25 = .depend.IDL_Test_IDL_Idl25
IDL_DEPENDENCY_FILE26 = .depend.IDL_Test_IDL_Idl26
IDL_DEPENDENCY_FILE27 = .depend.IDL_Test_IDL_Idl27
IDL_DEPENDENCY_FILE28 = .depend.IDL_Test_IDL_Idl28
IDL_DEPENDENCY_FILE29 = .depend.IDL_Test_IDL_Idl29
IDL_DEPENDENCY_FILE30 = .depend.IDL_Test_IDL_Idl30
IDL_DEPENDENCY_FILE31 = .depend.IDL_Test_IDL_Idl31
IDL_DEPENDENCY_FILE32 = .depend.IDL_Test_IDL_Idl32
IDL_DEPENDENCY_FILE33 = .depend.IDL_Test_IDL_Idl33
IDL_DEPENDENCY_FILE34 = .depend.IDL_Test_IDL_Idl34
IDL_DEPENDENCY_FILE35 = .depend.IDL_Test_IDL_Idl35
IDL_DEPENDENCY_FILE36 = .depend.IDL_Test_IDL_Idl36
IDL_DEPENDENCY_FILE37 = .depend.IDL_Test_IDL_Idl37
IDL_DEPENDENCY_FILE38 = .depend.IDL_Test_IDL_Idl38
IDL_DEPENDENCY_FILE39 = .depend.IDL_Test_IDL_Idl39
IDL_DEPENDENCY_FILE40 = .depend.IDL_Test_IDL_Idl40
IDL_DEPENDENCY_FILE41 = .depend.IDL_Test_IDL_Idl41
IDL_DEPENDENCY_FILE42 = .depend.IDL_Test_IDL_Idl42
IDL_DEPENDENCY_FILE43 = .depend.IDL_Test_IDL_Idl43
IDL_DEPENDENCY_FILE44 = .depend.IDL_Test_IDL_Idl44
IDL_DEPENDENCY_FILE45 = .depend.IDL_Test_IDL_Idl45
IDL_DEPENDENCY_FILE46 = .depend.IDL_Test_IDL_Idl46
IDL_DEPENDENCY_FILE47 = .depend.IDL_Test_IDL_Idl47
IDL_DEPENDENCY_FILE48 = .depend.IDL_Test_IDL_Idl48
IDL_DEPENDENCY_FILE49 = .depend.IDL_Test_IDL_Idl49
IDL_DEPENDENCY_FILE50 = .depend.IDL_Test_IDL_Idl50
IDL_DEPENDENCY_FILE51 = .depend.IDL_Test_IDL_Idl51
IDL_DEPENDENCY_FILE52 = .depend.IDL_Test_IDL_Idl52
IDL_DEPENDENCY_FILE53 = .depend.IDL_Test_IDL_Idl53
IDL_DEPENDENCY_FILE54 = .depend.IDL_Test_IDL_Idl54

IDL_DEPENDENCY_FILES += \
	.depend.IDL_Test_IDL_Idl1 \
	.depend.IDL_Test_IDL_Idl2 \
	.depend.IDL_Test_IDL_Idl3 \
	.depend.IDL_Test_IDL_Idl4 \
	.depend.IDL_Test_IDL_Idl5 \
	.depend.IDL_Test_IDL_Idl6 \
	.depend.IDL_Test_IDL_Idl7 \
	.depend.IDL_Test_IDL_Idl8 \
	.depend.IDL_Test_IDL_Idl9 \
	.depend.IDL_Test_IDL_Idl10 \
	.depend.IDL_Test_IDL_Idl11 \
	.depend.IDL_Test_IDL_Idl12 \
	.depend.IDL_Test_IDL_Idl13 \
	.depend.IDL_Test_IDL_Idl14 \
	.depend.IDL_Test_IDL_Idl15 \
	.depend.IDL_Test_IDL_Idl16 \
	.depend.IDL_Test_IDL_Idl17 \
	.depend.IDL_Test_IDL_Idl18 \
	.depend.IDL_Test_IDL_Idl19 \
	.depend.IDL_Test_IDL_Idl20 \
	.depend.IDL_Test_IDL_Idl21 \
	.depend.IDL_Test_IDL_Idl22 \
	.depend.IDL_Test_IDL_Idl23 \
	.depend.IDL_Test_IDL_Idl24 \
	.depend.IDL_Test_IDL_Idl25 \
	.depend.IDL_Test_IDL_Idl26 \
	.depend.IDL_Test_IDL_Idl27 \
	.depend.IDL_Test_IDL_Idl28 \
	.depend.IDL_Test_IDL_Idl29 \
	.depend.IDL_Test_IDL_Idl30 \
	.depend.IDL_Test_IDL_Idl31 \
	.depend.IDL_Test_IDL_Idl32 \
	.depend.IDL_Test_IDL_Idl33 \
	.depend.IDL_Test_IDL_Idl34 \
	.depend.IDL_Test_IDL_Idl35 \
	.depend.IDL_Test_IDL_Idl36 \
	.depend.IDL_Test_IDL_Idl37 \
	.depend.IDL_Test_IDL_Idl38 \
	.depend.IDL_Test_IDL_Idl39 \
	.depend.IDL_Test_IDL_Idl40 \
	.depend.IDL_Test_IDL_Idl41 \
	.depend.IDL_Test_IDL_Idl42 \
	.depend.IDL_Test_IDL_Idl43 \
	.depend.IDL_Test_IDL_Idl44 \
	.depend.IDL_Test_IDL_Idl45 \
	.depend.IDL_Test_IDL_Idl46 \
	.depend.IDL_Test_IDL_Idl47 \
	.depend.IDL_Test_IDL_Idl48 \
	.depend.IDL_Test_IDL_Idl49 \
	.depend.IDL_Test_IDL_Idl50 \
	.depend.IDL_Test_IDL_Idl51 \
	.depend.IDL_Test_IDL_Idl52 \
	.depend.IDL_Test_IDL_Idl53 \
	.depend.IDL_Test_IDL_Idl54

LIB_PREFIX      ?= lib

TAO_ROOT  ?= $(ACE_ROOT)/TAO

FILES = \

IDL_DEPS_FLAGS1 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -Gxhst
IDL_DEPS1 = attribute.idl

IDL_DEPS_FLAGS2 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS2 = Bug_2350_Regression.idl

IDL_DEPS_FLAGS3 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS3 = Bug_2577_Regression.idl

IDL_DEPS_FLAGS4 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS4 = Bug_2582_Regression.idl

IDL_DEPS_FLAGS5 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS5 = Bug_2583_Regression.idl

IDL_DEPS_FLAGS6 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS6 = Bug_2616_Regression.idl

IDL_DEPS_FLAGS7 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS7 = Bug_2619_Regression.idl

IDL_DEPS_FLAGS8 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS8 = Bug_3243_Regression.idl

IDL_DEPS_FLAGS9 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS9 = Bug_3312_Regression.idl

IDL_DEPS_FLAGS10 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS10 = Bug_3819_Regression.idl

IDL_DEPS_FLAGS11 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS11 = Bug_3821_Regression.idl

IDL_DEPS_FLAGS12 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS12 = full.idl

IDL_DEPS_FLAGS13 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS13 = fwd.idl

IDL_DEPS_FLAGS14 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS14 = gperf.idl

IDL_DEPS_FLAGS15 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS15 = interface.idl

IDL_DEPS_FLAGS16 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS16 = nested_scope.idl

IDL_DEPS_FLAGS17 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS17 = old_constants.idl

IDL_DEPS_FLAGS18 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS18 = simple.idl

IDL_DEPS_FLAGS19 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS19 = simple2.idl

IDL_DEPS_FLAGS20 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS20 = old_array.idl

IDL_DEPS_FLAGS21 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS21 = old_sequence.idl

IDL_DEPS_FLAGS22 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS22 = old_struct.idl

IDL_DEPS_FLAGS23 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS23 = old_union.idl

IDL_DEPS_FLAGS24 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS24 = old_union2.idl

IDL_DEPS_FLAGS25 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS25 = params.idl

IDL_DEPS_FLAGS26 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS26 = reopened_modules.idl

IDL_DEPS_FLAGS27 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS27 = struct.idl

IDL_DEPS_FLAGS28 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS28 = string_value.idl

IDL_DEPS_FLAGS29 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS29 = reopen_include1.idl

IDL_DEPS_FLAGS30 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS30 = reopen_include2.idl

IDL_DEPS_FLAGS31 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd
IDL_DEPS31 = typeprefix.idl

IDL_DEPS_FLAGS32 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS32 = enum_in_struct.idl

IDL_DEPS_FLAGS33 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS33 = array.idl

IDL_DEPS_FLAGS34 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS34 = array_anon_nested.idl

IDL_DEPS_FLAGS35 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS35 = included.idl

IDL_DEPS_FLAGS36 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS36 = including.idl

IDL_DEPS_FLAGS37 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS37 = sequence.idl

IDL_DEPS_FLAGS38 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS38 = union.idl

IDL_DEPS_FLAGS39 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS39 = anyunion.idl

IDL_DEPS_FLAGS40 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as
IDL_DEPS40 = valuetype.idl

IDL_DEPS_FLAGS41 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA -as
IDL_DEPS41 = anonymous.idl

IDL_DEPS_FLAGS42 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA -as
IDL_DEPS42 = dif2.idl

IDL_DEPS_FLAGS43 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS43 = array_only.idl

IDL_DEPS_FLAGS44 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS44 = constants.idl

IDL_DEPS_FLAGS45 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS45 = generic_object.idl

IDL_DEPS_FLAGS46 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS46 = keywords.idl

IDL_DEPS_FLAGS47 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS47 = inherit.idl

IDL_DEPS_FLAGS48 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS48 = module.idl

IDL_DEPS_FLAGS49 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS49 = primtypes.idl

IDL_DEPS_FLAGS50 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS50 = pragma.idl

IDL_DEPS_FLAGS51 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS51 = repo_id_mod.idl

IDL_DEPS_FLAGS52 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS52 = typedef.idl

IDL_DEPS_FLAGS53 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA
IDL_DEPS53 = typecode.idl

IDL_DEPS_FLAGS54 = $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd loader_const.idl
IDL_DEPS54 = PEMNaming.idl



LIBPATHS := . "../../../lib"

#----------------------------------------------------------------------------
#       Include macros and targets
#----------------------------------------------------------------------------
TAO_IDL = ../../../bin/tao_idl
TAO_IDL_DEP = ../../../bin/tao_idl$(EXEEXT)
TAO_IDLFLAGS = -Wb,pre_include=ace/pre.h -Wb,post_include=ace/post.h -I../..$(if $(ARCH), -g $(call ADD_QUOTE,$(call ADD_ARCH,$(ACE_ROOT)/bin/ace_gperf)))

PRJ_TYPE = library

COLLAPSE_SLASHES = $(if $(findstring //,$(1)),$(call COLLAPSE_SLASHES,$(subst //,/,$(1))),$(1))
INSLIB ?= $(call COLLAPSE_SLASHES,.)
ifeq ($(INSLIB),.)
  ifeq ($(CURDIR),)
    ifeq ($(PWD),)
      PWD=$(shell pwd)
    endif
  else
    PWD=$(CURDIR)
  endif
  INSLIB = $(PWD)
endif
OUTPUT_DIRECTORY = $(INSLIB)

include $(ACE_ROOT)/include/makeinclude/wrapper_macros.GNU

include $(TAO_ROOT)/rules.tao.GNU

GNUACE_PROJECT_VERSION ?= $(ACE_VERSION)

# To build multiple targets in the same directory on AIX, it works
# best to have a template directory per project.
# The compiler/linker isn't too smart about instantiating templates...
ifdef TEMPINCDIR
TEMPINCDIR := $(TEMPINCDIR)/IDL_Test_IDL
all: $(TEMPINCDIR)
endif

ifneq ($(OUTPUT_DIRECTORY),)
.PHONY: create_output_directory.local
all: create_output_directory.local
create_output_directory.local:
	-@$(MKDIR) "$(OUTPUT_DIRECTORY)" $(ACE_NUL_STDERR)
endif

LIBCHECK = 1
ifeq ($(corba_messaging),1)
ifneq ($(LIBCHECK), 1)
  all: lib_warning
endif
else
  all: require_warning
endif

ifeq ($(corba_messaging),1)
else
  all: require_warning
endif

include $(ACE_ROOT)/include/makeinclude/macros.GNU
include $(ACE_ROOT)/include/makeinclude/rules.common.GNU
include $(ACE_ROOT)/include/makeinclude/rules.nonested.GNU
include $(ACE_ROOT)/include/makeinclude/rules.local.GNU
ifeq ($(VXWORKSLINK),1)
include $(TGT_DIR)/h/make/rules.$(PRJ_TYPE)
endif

ifeq ($(VXWORKSLINK),1)
LDLIBPATH     = -L. -L../../../lib
else
LDFLAGS      += -L. $(if $(ARCH),-L./$(ARCH)) -L../../../lib $(if $(ARCH),-L../../../lib/$(ARCH))
endif
CPPFLAGS     += -I../../.. -I../..
ifeq ($(static_libs),1)
  CPPFLAGS += -DACE_AS_STATIC_LIBS -DTAO_AS_STATIC_LIBS
endif

#----------------------------------------------------------------------------
#       Local targets
#----------------------------------------------------------------------------
lib_warning:
	@echo IDL_Test_IDL will not be built due to the following missing library: $(LIBCHECK) >&2

ifneq ($(corba_messaging),1)
requires_disabled_macros += corba_messaging
endif
require_warning:
	@echo IDL_Test_IDL will not be built due to the following disabled make macros: $(requires_disabled_macros)>&2

## Some OS's have /bin/test others only have /usr/bin/test
ifeq ($(wildcard /bin/test), /bin/test)
  TEST_EXE = /bin/test
else
ifeq ($(wildcard /usr/bin/test), /usr/bin/test)
  TEST_EXE = /usr/bin/test
endif
endif

SPACE = $(should_be_unset) $(should_be_unset)
export DYLD_LIBRARY_PATH := $(DYLD_LIBRARY_PATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))
export LD_LIBRARY_PATH   := $(LD_LIBRARY_PATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))
export SHLIB_PATH        := $(SHLIB_PATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))
export LIBPATH           := $(LIBPATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))
export PATH              := $(PATH):../../../lib$(if $(ARCH),:../../../lib/$(ARCH))

GENERATED_DIRTY += attributeS_T.cpp attributeS.cpp attributeC.cpp attributeC.inl attributeC.h attributeS.h attributeS_T.h TAO_IDL_TEST_stub_export.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "attribute.idl" -nt "attributeS_T.cpp" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeS.cpp" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeC.cpp" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeC.inl" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeC.h" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeS.h" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "attributeS_T.h" 2> /dev/null || $(TEST_EXE) "attribute.idl" -nt "TAO_IDL_TEST_stub_export.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "attributeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "TAO_IDL_TEST_stub_export.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "attributeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "TAO_IDL_TEST_stub_export.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "attributeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "TAO_IDL_TEST_stub_export.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
attributeS_T.cpp attributeS.cpp attributeC.cpp attributeC.inl attributeC.h attributeS.h attributeS_T.h TAO_IDL_TEST_stub_export.h: attribute.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -Gxhst attribute.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
attributeS_T.cpp attributeS.cpp attributeC.cpp attributeC.inl attributeC.h attributeS.h attributeS_T.h TAO_IDL_TEST_stub_export.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2350_RegressionS_T.cpp Bug_2350_RegressionS.cpp Bug_2350_RegressionC.cpp Bug_2350_RegressionC.inl Bug_2350_RegressionC.h Bug_2350_RegressionS.h Bug_2350_RegressionS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2350_Regression.idl" -nt "Bug_2350_RegressionS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2350_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2350_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2350_RegressionS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2350_RegressionS_T.cpp Bug_2350_RegressionS.cpp Bug_2350_RegressionC.cpp Bug_2350_RegressionC.inl Bug_2350_RegressionC.h Bug_2350_RegressionS.h Bug_2350_RegressionS_T.h: Bug_2350_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_2350_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2350_RegressionS_T.cpp Bug_2350_RegressionS.cpp Bug_2350_RegressionC.cpp Bug_2350_RegressionC.inl Bug_2350_RegressionC.h Bug_2350_RegressionS.h Bug_2350_RegressionS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2577_RegressionS_T.cpp Bug_2577_RegressionS.cpp Bug_2577_RegressionC.cpp Bug_2577_RegressionC.inl Bug_2577_RegressionC.h Bug_2577_RegressionS.h Bug_2577_RegressionS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2577_Regression.idl" -nt "Bug_2577_RegressionS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2577_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2577_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2577_RegressionS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2577_RegressionS_T.cpp Bug_2577_RegressionS.cpp Bug_2577_RegressionC.cpp Bug_2577_RegressionC.inl Bug_2577_RegressionC.h Bug_2577_RegressionS.h Bug_2577_RegressionS_T.h: Bug_2577_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_2577_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2577_RegressionS_T.cpp Bug_2577_RegressionS.cpp Bug_2577_RegressionC.cpp Bug_2577_RegressionC.inl Bug_2577_RegressionC.h Bug_2577_RegressionS.h Bug_2577_RegressionS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2582_RegressionS_T.cpp Bug_2582_RegressionS.cpp Bug_2582_RegressionC.cpp Bug_2582_RegressionC.inl Bug_2582_RegressionC.h Bug_2582_RegressionS.h Bug_2582_RegressionS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2582_Regression.idl" -nt "Bug_2582_RegressionS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2582_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2582_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2582_RegressionS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2582_RegressionS_T.cpp Bug_2582_RegressionS.cpp Bug_2582_RegressionC.cpp Bug_2582_RegressionC.inl Bug_2582_RegressionC.h Bug_2582_RegressionS.h Bug_2582_RegressionS_T.h: Bug_2582_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_2582_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2582_RegressionS_T.cpp Bug_2582_RegressionS.cpp Bug_2582_RegressionC.cpp Bug_2582_RegressionC.inl Bug_2582_RegressionC.h Bug_2582_RegressionS.h Bug_2582_RegressionS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2583_RegressionS_T.cpp Bug_2583_RegressionS.cpp Bug_2583_RegressionC.cpp Bug_2583_RegressionC.inl Bug_2583_RegressionC.h Bug_2583_RegressionS.h Bug_2583_RegressionS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2583_Regression.idl" -nt "Bug_2583_RegressionS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2583_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2583_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2583_RegressionS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2583_RegressionS_T.cpp Bug_2583_RegressionS.cpp Bug_2583_RegressionC.cpp Bug_2583_RegressionC.inl Bug_2583_RegressionC.h Bug_2583_RegressionS.h Bug_2583_RegressionS_T.h: Bug_2583_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_2583_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2583_RegressionS_T.cpp Bug_2583_RegressionS.cpp Bug_2583_RegressionC.cpp Bug_2583_RegressionC.inl Bug_2583_RegressionC.h Bug_2583_RegressionS.h Bug_2583_RegressionS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2616_RegressionS_T.cpp Bug_2616_RegressionS.cpp Bug_2616_RegressionC.cpp Bug_2616_RegressionC.inl Bug_2616_RegressionC.h Bug_2616_RegressionS.h Bug_2616_RegressionS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2616_Regression.idl" -nt "Bug_2616_RegressionS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2616_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2616_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2616_RegressionS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2616_RegressionS_T.cpp Bug_2616_RegressionS.cpp Bug_2616_RegressionC.cpp Bug_2616_RegressionC.inl Bug_2616_RegressionC.h Bug_2616_RegressionS.h Bug_2616_RegressionS_T.h: Bug_2616_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_2616_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2616_RegressionS_T.cpp Bug_2616_RegressionS.cpp Bug_2616_RegressionC.cpp Bug_2616_RegressionC.inl Bug_2616_RegressionC.h Bug_2616_RegressionS.h Bug_2616_RegressionS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_2619_RegressionS_T.cpp Bug_2619_RegressionS.cpp Bug_2619_RegressionC.cpp Bug_2619_RegressionC.inl Bug_2619_RegressionC.h Bug_2619_RegressionS.h Bug_2619_RegressionS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_2619_Regression.idl" -nt "Bug_2619_RegressionS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_2619_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_2619_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_2619_RegressionS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_2619_RegressionS_T.cpp Bug_2619_RegressionS.cpp Bug_2619_RegressionC.cpp Bug_2619_RegressionC.inl Bug_2619_RegressionC.h Bug_2619_RegressionS.h Bug_2619_RegressionS_T.h: Bug_2619_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_2619_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_2619_RegressionS_T.cpp Bug_2619_RegressionS.cpp Bug_2619_RegressionC.cpp Bug_2619_RegressionC.inl Bug_2619_RegressionC.h Bug_2619_RegressionS.h Bug_2619_RegressionS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_3243_RegressionS_T.cpp Bug_3243_RegressionS.cpp Bug_3243_RegressionC.cpp Bug_3243_RegressionC.inl Bug_3243_RegressionC.h Bug_3243_RegressionS.h Bug_3243_RegressionS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_3243_Regression.idl" -nt "Bug_3243_RegressionS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3243_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3243_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3243_RegressionS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_3243_RegressionS_T.cpp Bug_3243_RegressionS.cpp Bug_3243_RegressionC.cpp Bug_3243_RegressionC.inl Bug_3243_RegressionC.h Bug_3243_RegressionS.h Bug_3243_RegressionS_T.h: Bug_3243_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_3243_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_3243_RegressionS_T.cpp Bug_3243_RegressionS.cpp Bug_3243_RegressionC.cpp Bug_3243_RegressionC.inl Bug_3243_RegressionC.h Bug_3243_RegressionS.h Bug_3243_RegressionS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_3312_RegressionS_T.cpp Bug_3312_RegressionS.cpp Bug_3312_RegressionC.cpp Bug_3312_RegressionC.inl Bug_3312_RegressionC.h Bug_3312_RegressionS.h Bug_3312_RegressionS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_3312_Regression.idl" -nt "Bug_3312_RegressionS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3312_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3312_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3312_RegressionS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_3312_RegressionS_T.cpp Bug_3312_RegressionS.cpp Bug_3312_RegressionC.cpp Bug_3312_RegressionC.inl Bug_3312_RegressionC.h Bug_3312_RegressionS.h Bug_3312_RegressionS_T.h: Bug_3312_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_3312_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_3312_RegressionS_T.cpp Bug_3312_RegressionS.cpp Bug_3312_RegressionC.cpp Bug_3312_RegressionC.inl Bug_3312_RegressionC.h Bug_3312_RegressionS.h Bug_3312_RegressionS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_3819_RegressionS_T.cpp Bug_3819_RegressionS.cpp Bug_3819_RegressionC.cpp Bug_3819_RegressionC.inl Bug_3819_RegressionC.h Bug_3819_RegressionS.h Bug_3819_RegressionS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_3819_Regression.idl" -nt "Bug_3819_RegressionS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3819_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3819_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3819_RegressionS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_3819_RegressionS_T.cpp Bug_3819_RegressionS.cpp Bug_3819_RegressionC.cpp Bug_3819_RegressionC.inl Bug_3819_RegressionC.h Bug_3819_RegressionS.h Bug_3819_RegressionS_T.h: Bug_3819_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_3819_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_3819_RegressionS_T.cpp Bug_3819_RegressionS.cpp Bug_3819_RegressionC.cpp Bug_3819_RegressionC.inl Bug_3819_RegressionC.h Bug_3819_RegressionS.h Bug_3819_RegressionS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += Bug_3821_RegressionS_T.cpp Bug_3821_RegressionS.cpp Bug_3821_RegressionC.cpp Bug_3821_RegressionC.inl Bug_3821_RegressionC.h Bug_3821_RegressionS.h Bug_3821_RegressionS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionC.h" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionS.h" 2> /dev/null || $(TEST_EXE) "Bug_3821_Regression.idl" -nt "Bug_3821_RegressionS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "Bug_3821_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "Bug_3821_RegressionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "Bug_3821_RegressionS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
Bug_3821_RegressionS_T.cpp Bug_3821_RegressionS.cpp Bug_3821_RegressionC.cpp Bug_3821_RegressionC.inl Bug_3821_RegressionC.h Bug_3821_RegressionS.h Bug_3821_RegressionS_T.h: Bug_3821_Regression.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd Bug_3821_Regression.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
Bug_3821_RegressionS_T.cpp Bug_3821_RegressionS.cpp Bug_3821_RegressionC.cpp Bug_3821_RegressionC.inl Bug_3821_RegressionC.h Bug_3821_RegressionS.h Bug_3821_RegressionS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += fullS_T.cpp fullS.cpp fullC.cpp fullC.inl fullC.h fullS.h fullS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "full.idl" -nt "fullS_T.cpp" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullS.cpp" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullC.cpp" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullC.inl" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullC.h" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullS.h" 2> /dev/null || $(TEST_EXE) "full.idl" -nt "fullS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fullS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fullS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fullS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
fullS_T.cpp fullS.cpp fullC.cpp fullC.inl fullC.h fullS.h fullS_T.h: full.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd full.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
fullS_T.cpp fullS.cpp fullC.cpp fullC.inl fullC.h fullS.h fullS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += fwdS_T.cpp fwdS.cpp fwdC.cpp fwdC.inl fwdC.h fwdS.h fwdS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "fwd.idl" -nt "fwdS_T.cpp" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdS.cpp" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdC.cpp" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdC.inl" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdC.h" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdS.h" 2> /dev/null || $(TEST_EXE) "fwd.idl" -nt "fwdS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "fwdS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "fwdS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "fwdS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
fwdS_T.cpp fwdS.cpp fwdC.cpp fwdC.inl fwdC.h fwdS.h fwdS_T.h: fwd.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd fwd.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
fwdS_T.cpp fwdS.cpp fwdC.cpp fwdC.inl fwdC.h fwdS.h fwdS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += gperfS_T.cpp gperfS.cpp gperfC.cpp gperfC.inl gperfC.h gperfS.h gperfS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "gperf.idl" -nt "gperfS_T.cpp" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfS.cpp" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfC.cpp" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfC.inl" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfC.h" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfS.h" 2> /dev/null || $(TEST_EXE) "gperf.idl" -nt "gperfS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "gperfS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "gperfS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "gperfS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
gperfS_T.cpp gperfS.cpp gperfC.cpp gperfC.inl gperfC.h gperfS.h gperfS_T.h: gperf.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd gperf.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
gperfS_T.cpp gperfS.cpp gperfC.cpp gperfC.inl gperfC.h gperfS.h gperfS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += interfaceS_T.cpp interfaceS.cpp interfaceC.cpp interfaceC.inl interfaceC.h interfaceS.h interfaceS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "interface.idl" -nt "interfaceS_T.cpp" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceS.cpp" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceC.cpp" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceC.inl" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceC.h" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceS.h" 2> /dev/null || $(TEST_EXE) "interface.idl" -nt "interfaceS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "interfaceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "interfaceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "interfaceS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
interfaceS_T.cpp interfaceS.cpp interfaceC.cpp interfaceC.inl interfaceC.h interfaceS.h interfaceS_T.h: interface.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd interface.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
interfaceS_T.cpp interfaceS.cpp interfaceC.cpp interfaceC.inl interfaceC.h interfaceS.h interfaceS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += nested_scopeS_T.cpp nested_scopeS.cpp nested_scopeC.cpp nested_scopeC.inl nested_scopeC.h nested_scopeS.h nested_scopeS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeS_T.cpp" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeS.cpp" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeC.cpp" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeC.inl" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeC.h" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeS.h" 2> /dev/null || $(TEST_EXE) "nested_scope.idl" -nt "nested_scopeS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "nested_scopeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "nested_scopeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "nested_scopeS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
nested_scopeS_T.cpp nested_scopeS.cpp nested_scopeC.cpp nested_scopeC.inl nested_scopeC.h nested_scopeS.h nested_scopeS_T.h: nested_scope.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd nested_scope.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
nested_scopeS_T.cpp nested_scopeS.cpp nested_scopeC.cpp nested_scopeC.inl nested_scopeC.h nested_scopeS.h nested_scopeS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_constantsS_T.cpp old_constantsS.cpp old_constantsC.cpp old_constantsC.inl old_constantsC.h old_constantsS.h old_constantsS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_constants.idl" -nt "old_constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsS.cpp" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsC.cpp" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsC.inl" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsC.h" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsS.h" 2> /dev/null || $(TEST_EXE) "old_constants.idl" -nt "old_constantsS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_constantsS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_constantsS_T.cpp old_constantsS.cpp old_constantsC.cpp old_constantsC.inl old_constantsC.h old_constantsS.h old_constantsS_T.h: old_constants.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd old_constants.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_constantsS_T.cpp old_constantsS.cpp old_constantsC.cpp old_constantsC.inl old_constantsC.h old_constantsS.h old_constantsS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += simpleS_T.cpp simpleS.cpp simpleC.cpp simpleC.inl simpleC.h simpleS.h simpleS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "simple.idl" -nt "simpleS_T.cpp" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleS.cpp" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleC.cpp" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleC.inl" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleC.h" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleS.h" 2> /dev/null || $(TEST_EXE) "simple.idl" -nt "simpleS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simpleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simpleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simpleS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
simpleS_T.cpp simpleS.cpp simpleC.cpp simpleC.inl simpleC.h simpleS.h simpleS_T.h: simple.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd simple.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
simpleS_T.cpp simpleS.cpp simpleC.cpp simpleC.inl simpleC.h simpleS.h simpleS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += simple2S_T.cpp simple2S.cpp simple2C.cpp simple2C.inl simple2C.h simple2S.h simple2S_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "simple2.idl" -nt "simple2S_T.cpp" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2S.cpp" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2C.cpp" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2C.inl" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2C.h" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2S.h" 2> /dev/null || $(TEST_EXE) "simple2.idl" -nt "simple2S_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "simple2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "simple2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "simple2S_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
simple2S_T.cpp simple2S.cpp simple2C.cpp simple2C.inl simple2C.h simple2S.h simple2S_T.h: simple2.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd simple2.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
simple2S_T.cpp simple2S.cpp simple2C.cpp simple2C.inl simple2C.h simple2S.h simple2S_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_arrayS_T.cpp old_arrayS.cpp old_arrayC.cpp old_arrayC.inl old_arrayC.h old_arrayS.h old_arrayS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_array.idl" -nt "old_arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayS.cpp" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayC.cpp" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayC.inl" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayC.h" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayS.h" 2> /dev/null || $(TEST_EXE) "old_array.idl" -nt "old_arrayS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_arrayS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_arrayS_T.cpp old_arrayS.cpp old_arrayC.cpp old_arrayC.inl old_arrayC.h old_arrayS.h old_arrayS_T.h: old_array.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd old_array.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_arrayS_T.cpp old_arrayS.cpp old_arrayC.cpp old_arrayC.inl old_arrayC.h old_arrayS.h old_arrayS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_sequenceS_T.cpp old_sequenceS.cpp old_sequenceC.cpp old_sequenceC.inl old_sequenceC.h old_sequenceS.h old_sequenceS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceC.inl" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceC.h" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceS.h" 2> /dev/null || $(TEST_EXE) "old_sequence.idl" -nt "old_sequenceS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_sequenceS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_sequenceS_T.cpp old_sequenceS.cpp old_sequenceC.cpp old_sequenceC.inl old_sequenceC.h old_sequenceS.h old_sequenceS_T.h: old_sequence.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd old_sequence.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_sequenceS_T.cpp old_sequenceS.cpp old_sequenceC.cpp old_sequenceC.inl old_sequenceC.h old_sequenceS.h old_sequenceS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_structS_T.cpp old_structS.cpp old_structC.cpp old_structC.inl old_structC.h old_structS.h old_structS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_struct.idl" -nt "old_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structS.cpp" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structC.cpp" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structC.inl" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structC.h" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structS.h" 2> /dev/null || $(TEST_EXE) "old_struct.idl" -nt "old_structS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_structS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_structS_T.cpp old_structS.cpp old_structC.cpp old_structC.inl old_structC.h old_structS.h old_structS_T.h: old_struct.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd old_struct.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_structS_T.cpp old_structS.cpp old_structC.cpp old_structC.inl old_structC.h old_structS.h old_structS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_unionS_T.cpp old_unionS.cpp old_unionC.cpp old_unionC.inl old_unionC.h old_unionS.h old_unionS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_union.idl" -nt "old_unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionS.cpp" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionC.cpp" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionC.inl" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionC.h" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionS.h" 2> /dev/null || $(TEST_EXE) "old_union.idl" -nt "old_unionS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_unionS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_unionS_T.cpp old_unionS.cpp old_unionC.cpp old_unionC.inl old_unionC.h old_unionS.h old_unionS_T.h: old_union.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd old_union.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_unionS_T.cpp old_unionS.cpp old_unionC.cpp old_unionC.inl old_unionC.h old_unionS.h old_unionS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += old_union2S_T.cpp old_union2S.cpp old_union2C.cpp old_union2C.inl old_union2C.h old_union2S.h old_union2S_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "old_union2.idl" -nt "old_union2S_T.cpp" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2S.cpp" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2C.cpp" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2C.inl" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2C.h" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2S.h" 2> /dev/null || $(TEST_EXE) "old_union2.idl" -nt "old_union2S_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "old_union2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "old_union2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "old_union2S_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
old_union2S_T.cpp old_union2S.cpp old_union2C.cpp old_union2C.inl old_union2C.h old_union2S.h old_union2S_T.h: old_union2.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd old_union2.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
old_union2S_T.cpp old_union2S.cpp old_union2C.cpp old_union2C.inl old_union2C.h old_union2S.h old_union2S_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += paramsS_T.cpp paramsS.cpp paramsC.cpp paramsC.inl paramsC.h paramsS.h paramsS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "params.idl" -nt "paramsS_T.cpp" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsS.cpp" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsC.cpp" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsC.inl" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsC.h" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsS.h" 2> /dev/null || $(TEST_EXE) "params.idl" -nt "paramsS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "paramsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "paramsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "paramsS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
paramsS_T.cpp paramsS.cpp paramsC.cpp paramsC.inl paramsC.h paramsS.h paramsS_T.h: params.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd params.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
paramsS_T.cpp paramsS.cpp paramsC.cpp paramsC.inl paramsC.h paramsS.h paramsS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += reopened_modulesS_T.cpp reopened_modulesS.cpp reopened_modulesC.cpp reopened_modulesC.inl reopened_modulesC.h reopened_modulesS.h reopened_modulesS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesS_T.cpp" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesS.cpp" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesC.cpp" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesC.inl" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesC.h" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesS.h" 2> /dev/null || $(TEST_EXE) "reopened_modules.idl" -nt "reopened_modulesS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopened_modulesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopened_modulesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopened_modulesS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
reopened_modulesS_T.cpp reopened_modulesS.cpp reopened_modulesC.cpp reopened_modulesC.inl reopened_modulesC.h reopened_modulesS.h reopened_modulesS_T.h: reopened_modules.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd reopened_modules.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
reopened_modulesS_T.cpp reopened_modulesS.cpp reopened_modulesC.cpp reopened_modulesC.inl reopened_modulesC.h reopened_modulesS.h reopened_modulesS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += structS_T.cpp structS.cpp structC.cpp structC.inl structC.h structS.h structS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "struct.idl" -nt "structS_T.cpp" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structS.cpp" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structC.cpp" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structC.inl" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structC.h" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structS.h" 2> /dev/null || $(TEST_EXE) "struct.idl" -nt "structS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "structS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
structS_T.cpp structS.cpp structC.cpp structC.inl structC.h structS.h structS_T.h: struct.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd struct.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
structS_T.cpp structS.cpp structC.cpp structC.inl structC.h structS.h structS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += string_valueS_T.cpp string_valueS.cpp string_valueC.cpp string_valueC.inl string_valueC.h string_valueS.h string_valueS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "string_value.idl" -nt "string_valueS_T.cpp" 2> /dev/null || $(TEST_EXE) "string_value.idl" -nt "string_valueS.cpp" 2> /dev/null || $(TEST_EXE) "string_value.idl" -nt "string_valueC.cpp" 2> /dev/null || $(TEST_EXE) "string_value.idl" -nt "string_valueC.inl" 2> /dev/null || $(TEST_EXE) "string_value.idl" -nt "string_valueC.h" 2> /dev/null || $(TEST_EXE) "string_value.idl" -nt "string_valueS.h" 2> /dev/null || $(TEST_EXE) "string_value.idl" -nt "string_valueS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "string_valueS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "string_valueS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "string_valueS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
string_valueS_T.cpp string_valueS.cpp string_valueC.cpp string_valueC.inl string_valueC.h string_valueS.h string_valueS_T.h: string_value.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd string_value.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
string_valueS_T.cpp string_valueS.cpp string_valueC.cpp string_valueC.inl string_valueC.h string_valueS.h string_valueS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += reopen_include1S_T.cpp reopen_include1S.cpp reopen_include1C.cpp reopen_include1C.inl reopen_include1C.h reopen_include1S.h reopen_include1S_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1S_T.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1S.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1C.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1C.inl" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1C.h" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1S.h" 2> /dev/null || $(TEST_EXE) "reopen_include1.idl" -nt "reopen_include1S_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include1S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include1S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include1S_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
reopen_include1S_T.cpp reopen_include1S.cpp reopen_include1C.cpp reopen_include1C.inl reopen_include1C.h reopen_include1S.h reopen_include1S_T.h: reopen_include1.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd reopen_include1.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
reopen_include1S_T.cpp reopen_include1S.cpp reopen_include1C.cpp reopen_include1C.inl reopen_include1C.h reopen_include1S.h reopen_include1S_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += reopen_include2S_T.cpp reopen_include2S.cpp reopen_include2C.cpp reopen_include2C.inl reopen_include2C.h reopen_include2S.h reopen_include2S_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2S_T.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2S.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2C.cpp" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2C.inl" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2C.h" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2S.h" 2> /dev/null || $(TEST_EXE) "reopen_include2.idl" -nt "reopen_include2S_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "reopen_include2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "reopen_include2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "reopen_include2S_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
reopen_include2S_T.cpp reopen_include2S.cpp reopen_include2C.cpp reopen_include2C.inl reopen_include2C.h reopen_include2S.h reopen_include2S_T.h: reopen_include2.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd reopen_include2.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
reopen_include2S_T.cpp reopen_include2S.cpp reopen_include2C.cpp reopen_include2C.inl reopen_include2C.h reopen_include2S.h reopen_include2S_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += typeprefixS_T.cpp typeprefixS.cpp typeprefixC.cpp typeprefixC.inl typeprefixC.h typeprefixS.h typeprefixS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "typeprefix.idl" -nt "typeprefixS_T.cpp" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixS.cpp" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixC.cpp" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixC.inl" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixC.h" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixS.h" 2> /dev/null || $(TEST_EXE) "typeprefix.idl" -nt "typeprefixS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typeprefixS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typeprefixS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typeprefixS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
typeprefixS_T.cpp typeprefixS.cpp typeprefixC.cpp typeprefixC.inl typeprefixC.h typeprefixS.h typeprefixS_T.h: typeprefix.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd typeprefix.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
typeprefixS_T.cpp typeprefixS.cpp typeprefixC.cpp typeprefixC.inl typeprefixC.h typeprefixS.h typeprefixS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += enum_in_structS_T.cpp enum_in_structS.cpp enum_in_structC.cpp enum_in_structC.inl enum_in_structC.h enum_in_structS.h enum_in_structS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structS.cpp" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structC.cpp" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structC.inl" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structC.h" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structS.h" 2> /dev/null || $(TEST_EXE) "enum_in_struct.idl" -nt "enum_in_structS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "enum_in_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "enum_in_structS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "enum_in_structS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
enum_in_structS_T.cpp enum_in_structS.cpp enum_in_structC.cpp enum_in_structC.inl enum_in_structC.h enum_in_structS.h enum_in_structS_T.h: enum_in_struct.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as enum_in_struct.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
enum_in_structS_T.cpp enum_in_structS.cpp enum_in_structC.cpp enum_in_structC.inl enum_in_structC.h enum_in_structS.h enum_in_structS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += arrayS_T.cpp arrayS.cpp arrayC.cpp arrayC.inl arrayC.h arrayS.h arrayS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "array.idl" -nt "arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayS.cpp" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayC.cpp" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayC.inl" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayC.h" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayS.h" 2> /dev/null || $(TEST_EXE) "array.idl" -nt "arrayS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "arrayS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "arrayS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
arrayS_T.cpp arrayS.cpp arrayC.cpp arrayC.inl arrayC.h arrayS.h arrayS_T.h: array.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as array.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
arrayS_T.cpp arrayS.cpp arrayC.cpp arrayC.inl arrayC.h arrayS.h arrayS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += array_anon_nestedS_T.cpp array_anon_nestedS.cpp array_anon_nestedC.cpp array_anon_nestedC.inl array_anon_nestedC.h array_anon_nestedS.h array_anon_nestedS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedS_T.cpp" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedS.cpp" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedC.cpp" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedC.inl" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedC.h" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedS.h" 2> /dev/null || $(TEST_EXE) "array_anon_nested.idl" -nt "array_anon_nestedS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_anon_nestedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_anon_nestedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_anon_nestedS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
array_anon_nestedS_T.cpp array_anon_nestedS.cpp array_anon_nestedC.cpp array_anon_nestedC.inl array_anon_nestedC.h array_anon_nestedS.h array_anon_nestedS_T.h: array_anon_nested.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as array_anon_nested.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
array_anon_nestedS_T.cpp array_anon_nestedS.cpp array_anon_nestedC.cpp array_anon_nestedC.inl array_anon_nestedC.h array_anon_nestedS.h array_anon_nestedS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += includedS_T.cpp includedS.cpp includedC.cpp includedC.inl includedC.h includedS.h includedS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "included.idl" -nt "includedS_T.cpp" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedS.cpp" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedC.cpp" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedC.inl" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedC.h" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedS.h" 2> /dev/null || $(TEST_EXE) "included.idl" -nt "includedS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includedS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includedS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
includedS_T.cpp includedS.cpp includedC.cpp includedC.inl includedC.h includedS.h includedS_T.h: included.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as included.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
includedS_T.cpp includedS.cpp includedC.cpp includedC.inl includedC.h includedS.h includedS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += includingS_T.cpp includingS.cpp includingC.cpp includingC.inl includingC.h includingS.h includingS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "including.idl" -nt "includingS_T.cpp" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingS.cpp" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingC.cpp" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingC.inl" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingC.h" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingS.h" 2> /dev/null || $(TEST_EXE) "including.idl" -nt "includingS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "includingS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "includingS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "includingS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
includingS_T.cpp includingS.cpp includingC.cpp includingC.inl includingC.h includingS.h includingS_T.h: including.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as including.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
includingS_T.cpp includingS.cpp includingC.cpp includingC.inl includingC.h includingS.h includingS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += sequenceS_T.cpp sequenceS.cpp sequenceC.cpp sequenceC.inl sequenceC.h sequenceS.h sequenceS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "sequence.idl" -nt "sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceC.inl" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceC.h" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceS.h" 2> /dev/null || $(TEST_EXE) "sequence.idl" -nt "sequenceS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "sequenceS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "sequenceS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
sequenceS_T.cpp sequenceS.cpp sequenceC.cpp sequenceC.inl sequenceC.h sequenceS.h sequenceS_T.h: sequence.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as sequence.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
sequenceS_T.cpp sequenceS.cpp sequenceC.cpp sequenceC.inl sequenceC.h sequenceS.h sequenceS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += unionS_T.cpp unionS.cpp unionC.cpp unionC.inl unionC.h unionS.h unionS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "union.idl" -nt "unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionS.cpp" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionC.cpp" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionC.inl" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionC.h" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionS.h" 2> /dev/null || $(TEST_EXE) "union.idl" -nt "unionS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "unionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "unionS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
unionS_T.cpp unionS.cpp unionC.cpp unionC.inl unionC.h unionS.h unionS_T.h: union.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as union.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
unionS_T.cpp unionS.cpp unionC.cpp unionC.inl unionC.h unionS.h unionS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += anyunionS_T.cpp anyunionS.cpp anyunionC.cpp anyunionC.inl anyunionC.h anyunionS.h anyunionS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "anyunion.idl" -nt "anyunionS_T.cpp" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionS.cpp" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionC.cpp" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionC.inl" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionC.h" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionS.h" 2> /dev/null || $(TEST_EXE) "anyunion.idl" -nt "anyunionS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anyunionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anyunionS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anyunionS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
anyunionS_T.cpp anyunionS.cpp anyunionC.cpp anyunionC.inl anyunionC.h anyunionS.h anyunionS_T.h: anyunion.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as anyunion.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
anyunionS_T.cpp anyunionS.cpp anyunionC.cpp anyunionC.inl anyunionC.h anyunionS.h anyunionS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += valuetypeS_T.cpp valuetypeS.cpp valuetypeC.cpp valuetypeC.inl valuetypeC.h valuetypeS.h valuetypeS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "valuetype.idl" -nt "valuetypeS_T.cpp" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeS.cpp" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeC.cpp" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeC.inl" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeC.h" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeS.h" 2> /dev/null || $(TEST_EXE) "valuetype.idl" -nt "valuetypeS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "valuetypeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "valuetypeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "valuetypeS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
valuetypeS_T.cpp valuetypeS.cpp valuetypeC.cpp valuetypeC.inl valuetypeC.h valuetypeS.h valuetypeS_T.h: valuetype.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -as valuetype.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
valuetypeS_T.cpp valuetypeS.cpp valuetypeC.cpp valuetypeC.inl valuetypeC.h valuetypeS.h valuetypeS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += anonymousS_T.cpp anonymousA.cpp anonymousS.cpp anonymousC.cpp anonymousC.inl anonymousA.h anonymousC.h anonymousS.h anonymousS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "anonymous.idl" -nt "anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousA.cpp" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousC.inl" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousA.h" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousC.h" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousS.h" 2> /dev/null || $(TEST_EXE) "anonymous.idl" -nt "anonymousS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "anonymousS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "anonymousS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
anonymousS_T.cpp anonymousA.cpp anonymousS.cpp anonymousC.cpp anonymousC.inl anonymousA.h anonymousC.h anonymousS.h anonymousS_T.h: anonymous.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA -as anonymous.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
anonymousS_T.cpp anonymousA.cpp anonymousS.cpp anonymousC.cpp anonymousC.inl anonymousA.h anonymousC.h anonymousS.h anonymousS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += dif2S_T.cpp dif2A.cpp dif2S.cpp dif2C.cpp dif2C.inl dif2A.h dif2C.h dif2S.h dif2S_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "dif2.idl" -nt "dif2S_T.cpp" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2A.cpp" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2S.cpp" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2C.cpp" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2C.inl" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2A.h" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2C.h" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2S.h" 2> /dev/null || $(TEST_EXE) "dif2.idl" -nt "dif2S_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2A.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2A.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "dif2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2A.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2A.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "dif2S_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2S_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2A.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2S.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2C.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2C.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2A.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2C.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2S.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "dif2S_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
dif2S_T.cpp dif2A.cpp dif2S.cpp dif2C.cpp dif2C.inl dif2A.h dif2C.h dif2S.h dif2S_T.h: dif2.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA -as dif2.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
dif2S_T.cpp dif2A.cpp dif2S.cpp dif2C.cpp dif2C.inl dif2A.h dif2C.h dif2S.h dif2S_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += array_onlyS_T.cpp array_onlyA.cpp array_onlyS.cpp array_onlyC.cpp array_onlyC.inl array_onlyA.h array_onlyC.h array_onlyS.h array_onlyS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "array_only.idl" -nt "array_onlyS_T.cpp" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyA.cpp" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyS.cpp" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyC.cpp" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyC.inl" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyA.h" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyC.h" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyS.h" 2> /dev/null || $(TEST_EXE) "array_only.idl" -nt "array_onlyS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "array_onlyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "array_onlyS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "array_onlyS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
array_onlyS_T.cpp array_onlyA.cpp array_onlyS.cpp array_onlyC.cpp array_onlyC.inl array_onlyA.h array_onlyC.h array_onlyS.h array_onlyS_T.h: array_only.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA array_only.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
array_onlyS_T.cpp array_onlyA.cpp array_onlyS.cpp array_onlyC.cpp array_onlyC.inl array_onlyA.h array_onlyC.h array_onlyS.h array_onlyS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += constantsS_T.cpp constantsA.cpp constantsS.cpp constantsC.cpp constantsC.inl constantsA.h constantsC.h constantsS.h constantsS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "constants.idl" -nt "constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsA.cpp" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsS.cpp" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsC.cpp" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsC.inl" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsA.h" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsC.h" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsS.h" 2> /dev/null || $(TEST_EXE) "constants.idl" -nt "constantsS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "constantsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "constantsS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
constantsS_T.cpp constantsA.cpp constantsS.cpp constantsC.cpp constantsC.inl constantsA.h constantsC.h constantsS.h constantsS_T.h: constants.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA constants.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
constantsS_T.cpp constantsA.cpp constantsS.cpp constantsC.cpp constantsC.inl constantsA.h constantsC.h constantsS.h constantsS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += generic_objectS_T.cpp generic_objectA.cpp generic_objectS.cpp generic_objectC.cpp generic_objectC.inl generic_objectA.h generic_objectC.h generic_objectS.h generic_objectS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "generic_object.idl" -nt "generic_objectS_T.cpp" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectA.cpp" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectS.cpp" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectC.cpp" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectC.inl" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectA.h" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectC.h" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectS.h" 2> /dev/null || $(TEST_EXE) "generic_object.idl" -nt "generic_objectS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "generic_objectS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "generic_objectS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "generic_objectS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
generic_objectS_T.cpp generic_objectA.cpp generic_objectS.cpp generic_objectC.cpp generic_objectC.inl generic_objectA.h generic_objectC.h generic_objectS.h generic_objectS_T.h: generic_object.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA generic_object.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
generic_objectS_T.cpp generic_objectA.cpp generic_objectS.cpp generic_objectC.cpp generic_objectC.inl generic_objectA.h generic_objectC.h generic_objectS.h generic_objectS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += keywordsS_T.cpp keywordsA.cpp keywordsS.cpp keywordsC.cpp keywordsC.inl keywordsA.h keywordsC.h keywordsS.h keywordsS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "keywords.idl" -nt "keywordsS_T.cpp" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsA.cpp" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsS.cpp" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsC.cpp" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsC.inl" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsA.h" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsC.h" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsS.h" 2> /dev/null || $(TEST_EXE) "keywords.idl" -nt "keywordsS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "keywordsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "keywordsS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "keywordsS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
keywordsS_T.cpp keywordsA.cpp keywordsS.cpp keywordsC.cpp keywordsC.inl keywordsA.h keywordsC.h keywordsS.h keywordsS_T.h: keywords.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA keywords.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
keywordsS_T.cpp keywordsA.cpp keywordsS.cpp keywordsC.cpp keywordsC.inl keywordsA.h keywordsC.h keywordsS.h keywordsS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += inheritS_T.cpp inheritA.cpp inheritS.cpp inheritC.cpp inheritC.inl inheritA.h inheritC.h inheritS.h inheritS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "inherit.idl" -nt "inheritS_T.cpp" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritA.cpp" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritS.cpp" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritC.cpp" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritC.inl" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritA.h" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritC.h" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritS.h" 2> /dev/null || $(TEST_EXE) "inherit.idl" -nt "inheritS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "inheritS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "inheritS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "inheritS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
inheritS_T.cpp inheritA.cpp inheritS.cpp inheritC.cpp inheritC.inl inheritA.h inheritC.h inheritS.h inheritS_T.h: inherit.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA inherit.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
inheritS_T.cpp inheritA.cpp inheritS.cpp inheritC.cpp inheritC.inl inheritA.h inheritC.h inheritS.h inheritS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += moduleS_T.cpp moduleA.cpp moduleS.cpp moduleC.cpp moduleC.inl moduleA.h moduleC.h moduleS.h moduleS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "module.idl" -nt "moduleS_T.cpp" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleA.cpp" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleS.cpp" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleC.cpp" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleC.inl" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleA.h" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleC.h" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleS.h" 2> /dev/null || $(TEST_EXE) "module.idl" -nt "moduleS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "moduleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "moduleS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "moduleS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
moduleS_T.cpp moduleA.cpp moduleS.cpp moduleC.cpp moduleC.inl moduleA.h moduleC.h moduleS.h moduleS_T.h: module.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA module.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
moduleS_T.cpp moduleA.cpp moduleS.cpp moduleC.cpp moduleC.inl moduleA.h moduleC.h moduleS.h moduleS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += primtypesS_T.cpp primtypesA.cpp primtypesS.cpp primtypesC.cpp primtypesC.inl primtypesA.h primtypesC.h primtypesS.h primtypesS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "primtypes.idl" -nt "primtypesS_T.cpp" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesA.cpp" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesS.cpp" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesC.cpp" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesC.inl" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesA.h" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesC.h" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesS.h" 2> /dev/null || $(TEST_EXE) "primtypes.idl" -nt "primtypesS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "primtypesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "primtypesS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "primtypesS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
primtypesS_T.cpp primtypesA.cpp primtypesS.cpp primtypesC.cpp primtypesC.inl primtypesA.h primtypesC.h primtypesS.h primtypesS_T.h: primtypes.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA primtypes.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
primtypesS_T.cpp primtypesA.cpp primtypesS.cpp primtypesC.cpp primtypesC.inl primtypesA.h primtypesC.h primtypesS.h primtypesS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += pragmaS_T.cpp pragmaA.cpp pragmaS.cpp pragmaC.cpp pragmaC.inl pragmaA.h pragmaC.h pragmaS.h pragmaS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "pragma.idl" -nt "pragmaS_T.cpp" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaA.cpp" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaS.cpp" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaC.cpp" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaC.inl" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaA.h" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaC.h" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaS.h" 2> /dev/null || $(TEST_EXE) "pragma.idl" -nt "pragmaS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "pragmaS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "pragmaS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "pragmaS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
pragmaS_T.cpp pragmaA.cpp pragmaS.cpp pragmaC.cpp pragmaC.inl pragmaA.h pragmaC.h pragmaS.h pragmaS_T.h: pragma.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA pragma.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
pragmaS_T.cpp pragmaA.cpp pragmaS.cpp pragmaC.cpp pragmaC.inl pragmaA.h pragmaC.h pragmaS.h pragmaS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += repo_id_modS_T.cpp repo_id_modA.cpp repo_id_modS.cpp repo_id_modC.cpp repo_id_modC.inl repo_id_modA.h repo_id_modC.h repo_id_modS.h repo_id_modS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modS_T.cpp" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modA.cpp" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modS.cpp" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modC.cpp" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modC.inl" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modA.h" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modC.h" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modS.h" 2> /dev/null || $(TEST_EXE) "repo_id_mod.idl" -nt "repo_id_modS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "repo_id_modS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "repo_id_modS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "repo_id_modS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
repo_id_modS_T.cpp repo_id_modA.cpp repo_id_modS.cpp repo_id_modC.cpp repo_id_modC.inl repo_id_modA.h repo_id_modC.h repo_id_modS.h repo_id_modS_T.h: repo_id_mod.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA repo_id_mod.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
repo_id_modS_T.cpp repo_id_modA.cpp repo_id_modS.cpp repo_id_modC.cpp repo_id_modC.inl repo_id_modA.h repo_id_modC.h repo_id_modS.h repo_id_modS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += typedefS_T.cpp typedefA.cpp typedefS.cpp typedefC.cpp typedefC.inl typedefA.h typedefC.h typedefS.h typedefS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "typedef.idl" -nt "typedefS_T.cpp" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefA.cpp" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefS.cpp" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefC.cpp" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefC.inl" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefA.h" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefC.h" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefS.h" 2> /dev/null || $(TEST_EXE) "typedef.idl" -nt "typedefS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typedefS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typedefS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typedefS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
typedefS_T.cpp typedefA.cpp typedefS.cpp typedefC.cpp typedefC.inl typedefA.h typedefC.h typedefS.h typedefS_T.h: typedef.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA typedef.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
typedefS_T.cpp typedefA.cpp typedefS.cpp typedefC.cpp typedefC.inl typedefA.h typedefC.h typedefS.h typedefS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += typecodeS_T.cpp typecodeA.cpp typecodeS.cpp typecodeC.cpp typecodeC.inl typecodeA.h typecodeC.h typecodeS.h typecodeS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "typecode.idl" -nt "typecodeS_T.cpp" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeA.cpp" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeS.cpp" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeC.cpp" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeC.inl" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeA.h" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeC.h" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeS.h" 2> /dev/null || $(TEST_EXE) "typecode.idl" -nt "typecodeS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "typecodeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "typecodeS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeA.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeA.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "typecodeS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
typecodeS_T.cpp typecodeA.cpp typecodeS.cpp typecodeC.cpp typecodeC.inl typecodeA.h typecodeC.h typecodeS.h typecodeS_T.h: typecode.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd -GA typecode.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
typecodeS_T.cpp typecodeA.cpp typecodeS.cpp typecodeC.cpp typecodeC.inl typecodeA.h typecodeC.h typecodeS.h typecodeS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

GENERATED_DIRTY += PEMNamingS_T.cpp PEMNamingS.cpp PEMNamingC.cpp PEMNamingC.inl PEMNamingC.h PEMNamingS.h PEMNamingS_T.h
OBJS_DEPEND_ON_GENERATED = 1
## More than one file is generated by the command and therefore
## it can not be run in parallel.  Unfortunately, there is no way to
## say that only this rule can't be run in parallel.  However, we can
## determine if the generated files have already been generated.  If that's
## the case, then we don't need this special rule.
ifeq ($(wildcard $(GENERATED_DIRTY)), $(GENERATED_DIRTY))
  ## If we can find /bin/test, then we will continue
  ifneq ($(TEST_EXE),)
    ## If all of the generated files are there, then we need to check
    ## and make sure that the generated files are up-to-date.  If they are not
    ## then we need the special rule.
    ifeq ($(shell $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingS_T.cpp" 2> /dev/null || $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingS.cpp" 2> /dev/null || $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingC.cpp" 2> /dev/null || $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingC.inl" 2> /dev/null || $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingC.h" 2> /dev/null || $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingS.h" 2> /dev/null || $(TEST_EXE) "PEMNaming.idl" -nt "PEMNamingS_T.h" 2> /dev/null || echo 0),)
      .NOTPARALLEL:

    else
      ## By this point, all of the generated files are here and up-to-date
      ## with respect to the source file.  Now we need to make sure that
      ## they are up-to-date with respect to the generation tool.  If the tool
      ## is newer than the generated files, then we need the special rule.
      ifeq ($(shell $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,$(TAO_IDL_DEP))" -nt "PEMNamingS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT))" -nt "PEMNamingS_T.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingS_T.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingS.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingC.cpp" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingC.inl" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingC.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingS.h" 2> /dev/null || $(TEST_EXE) "$(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))" -nt "PEMNamingS_T.h" 2> /dev/null || echo 0),)
        .NOTPARALLEL:
      endif
    endif
  else
    .NOTPARALLEL:
  endif
else
.NOTPARALLEL:
endif
PEMNamingS_T.cpp PEMNamingS.cpp PEMNamingC.cpp PEMNamingC.inl PEMNamingC.h PEMNamingS.h PEMNamingS_T.h: PEMNaming.idl $(subst $(SPACE),\$(SPACE),$(call ADD_ARCH,$(TAO_IDL_DEP)))
	$(if $(findstring ",$(TAO_IDL)),$(TAO_IDL),$(call ADD_QUOTE,$(call ADD_ARCH,$(TAO_IDL)))) $(TAO_IDLFLAGS) -GC -GH -Gd -GT -Wb,stub_export_macro=TAO_IDL_TEST_STUB_Export -Wb,stub_export_include=TAO_IDL_TEST_stub_export.h -Wb,skel_export_macro=TAO_IDL_TEST_STUB_Export -Wb,skel_export_include=TAO_IDL_TEST_stub_export.h -Gsd loader_const.idl PEMNaming.idl


ifneq ($(static_libs_only),1)
ifneq ($(CROSS-COMPILE),1)
PEMNamingS_T.cpp PEMNamingS.cpp PEMNamingC.cpp PEMNamingC.inl PEMNamingC.h PEMNamingS.h PEMNamingS_T.h: $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_BE.$(SOEXT)) $(call ADD_ARCH,../../../lib/$(LIB_PREFIX)TAO_IDL_FE.$(SOEXT))
endif
endif

ifneq ($(GENERATED_DIRTY),)
.PRECIOUS: $(GENERATED_DIRTY)
ifeq ($(corba_messaging),1)
all: $(GENERATED_DIRTY)
endif
endif

ADDITIONAL_IDL_TARGETS += attribute$(IDL_CLIENT_HDR_EXT) Bug_2350_Regression$(IDL_CLIENT_HDR_EXT) Bug_2577_Regression$(IDL_CLIENT_HDR_EXT) Bug_2582_Regression$(IDL_CLIENT_HDR_EXT) Bug_2583_Regression$(IDL_CLIENT_HDR_EXT) Bug_2616_Regression$(IDL_CLIENT_HDR_EXT) Bug_2619_Regression$(IDL_CLIENT_HDR_EXT) Bug_3243_Regression$(IDL_CLIENT_HDR_EXT) Bug_3312_Regression$(IDL_CLIENT_HDR_EXT) Bug_3819_Regression$(IDL_CLIENT_HDR_EXT) Bug_3821_Regression$(IDL_CLIENT_HDR_EXT) full$(IDL_CLIENT_HDR_EXT) fwd$(IDL_CLIENT_HDR_EXT) gperf$(IDL_CLIENT_HDR_EXT) interface$(IDL_CLIENT_HDR_EXT) nested_scope$(IDL_CLIENT_HDR_EXT) old_constants$(IDL_CLIENT_HDR_EXT) simple$(IDL_CLIENT_HDR_EXT) simple2$(IDL_CLIENT_HDR_EXT) old_array$(IDL_CLIENT_HDR_EXT) old_sequence$(IDL_CLIENT_HDR_EXT) old_struct$(IDL_CLIENT_HDR_EXT) old_union$(IDL_CLIENT_HDR_EXT) old_union2$(IDL_CLIENT_HDR_EXT) params$(IDL_CLIENT_HDR_EXT) reopened_modules$(IDL_CLIENT_HDR_EXT) struct$(IDL_CLIENT_HDR_EXT) string_value$(IDL_CLIENT_HDR_EXT) reopen_include1$(IDL_CLIENT_HDR_EXT) reopen_include2$(IDL_CLIENT_HDR_EXT) typeprefix$(IDL_CLIENT_HDR_EXT) enum_in_struct$(IDL_CLIENT_HDR_EXT) array$(IDL_CLIENT_HDR_EXT) array_anon_nested$(IDL_CLIENT_HDR_EXT) included$(IDL_CLIENT_HDR_EXT) including$(IDL_CLIENT_HDR_EXT) sequence$(IDL_CLIENT_HDR_EXT) union$(IDL_CLIENT_HDR_EXT) anyunion$(IDL_CLIENT_HDR_EXT) valuetype$(IDL_CLIENT_HDR_EXT) anonymous$(IDL_CLIENT_HDR_EXT) dif2$(IDL_CLIENT_HDR_EXT) array_only$(IDL_CLIENT_HDR_EXT) constants$(IDL_CLIENT_HDR_EXT) generic_object$(IDL_CLIENT_HDR_EXT) keywords$(IDL_CLIENT_HDR_EXT) inherit$(IDL_CLIENT_HDR_EXT) module$(IDL_CLIENT_HDR_EXT) primtypes$(IDL_CLIENT_HDR_EXT) pragma$(IDL_CLIENT_HDR_EXT) repo_id_mod$(IDL_CLIENT_HDR_EXT) typedef$(IDL_CLIENT_HDR_EXT) typecode$(IDL_CLIENT_HDR_EXT) PEMNaming$(IDL_CLIENT_HDR_EXT)
idl_stubs: $(ADDITIONAL_IDL_TARGETS)

incremental_depend_idl::
	@$(RM) $(IDL_DEPENDENCY_FILE1)_idl.old
	@cp $(IDL_DEPENDENCY_FILE1) $(IDL_DEPENDENCY_FILE1)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE1) \
	$(IDL_DEPS_FLAGS1) -t gnuidl -DMAKEDEPEND $(IDL_DEPS1)
	@if cmp -s $(IDL_DEPENDENCY_FILE1) $(IDL_DEPENDENCY_FILE1)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS1)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS1)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE1)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE2)_idl.old
	@cp $(IDL_DEPENDENCY_FILE2) $(IDL_DEPENDENCY_FILE2)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE2) \
	$(IDL_DEPS_FLAGS2) -t gnuidl -DMAKEDEPEND $(IDL_DEPS2)
	@if cmp -s $(IDL_DEPENDENCY_FILE2) $(IDL_DEPENDENCY_FILE2)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS2)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS2)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE2)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE3)_idl.old
	@cp $(IDL_DEPENDENCY_FILE3) $(IDL_DEPENDENCY_FILE3)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE3) \
	$(IDL_DEPS_FLAGS3) -t gnuidl -DMAKEDEPEND $(IDL_DEPS3)
	@if cmp -s $(IDL_DEPENDENCY_FILE3) $(IDL_DEPENDENCY_FILE3)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS3)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS3)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE3)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE4)_idl.old
	@cp $(IDL_DEPENDENCY_FILE4) $(IDL_DEPENDENCY_FILE4)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE4) \
	$(IDL_DEPS_FLAGS4) -t gnuidl -DMAKEDEPEND $(IDL_DEPS4)
	@if cmp -s $(IDL_DEPENDENCY_FILE4) $(IDL_DEPENDENCY_FILE4)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS4)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS4)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE4)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE5)_idl.old
	@cp $(IDL_DEPENDENCY_FILE5) $(IDL_DEPENDENCY_FILE5)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE5) \
	$(IDL_DEPS_FLAGS5) -t gnuidl -DMAKEDEPEND $(IDL_DEPS5)
	@if cmp -s $(IDL_DEPENDENCY_FILE5) $(IDL_DEPENDENCY_FILE5)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS5)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS5)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE5)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE6)_idl.old
	@cp $(IDL_DEPENDENCY_FILE6) $(IDL_DEPENDENCY_FILE6)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE6) \
	$(IDL_DEPS_FLAGS6) -t gnuidl -DMAKEDEPEND $(IDL_DEPS6)
	@if cmp -s $(IDL_DEPENDENCY_FILE6) $(IDL_DEPENDENCY_FILE6)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS6)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS6)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE6)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE7)_idl.old
	@cp $(IDL_DEPENDENCY_FILE7) $(IDL_DEPENDENCY_FILE7)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE7) \
	$(IDL_DEPS_FLAGS7) -t gnuidl -DMAKEDEPEND $(IDL_DEPS7)
	@if cmp -s $(IDL_DEPENDENCY_FILE7) $(IDL_DEPENDENCY_FILE7)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS7)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS7)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE7)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE8)_idl.old
	@cp $(IDL_DEPENDENCY_FILE8) $(IDL_DEPENDENCY_FILE8)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE8) \
	$(IDL_DEPS_FLAGS8) -t gnuidl -DMAKEDEPEND $(IDL_DEPS8)
	@if cmp -s $(IDL_DEPENDENCY_FILE8) $(IDL_DEPENDENCY_FILE8)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS8)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS8)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE8)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE9)_idl.old
	@cp $(IDL_DEPENDENCY_FILE9) $(IDL_DEPENDENCY_FILE9)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE9) \
	$(IDL_DEPS_FLAGS9) -t gnuidl -DMAKEDEPEND $(IDL_DEPS9)
	@if cmp -s $(IDL_DEPENDENCY_FILE9) $(IDL_DEPENDENCY_FILE9)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS9)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS9)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE9)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE10)_idl.old
	@cp $(IDL_DEPENDENCY_FILE10) $(IDL_DEPENDENCY_FILE10)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE10) \
	$(IDL_DEPS_FLAGS10) -t gnuidl -DMAKEDEPEND $(IDL_DEPS10)
	@if cmp -s $(IDL_DEPENDENCY_FILE10) $(IDL_DEPENDENCY_FILE10)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS10)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS10)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE10)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE11)_idl.old
	@cp $(IDL_DEPENDENCY_FILE11) $(IDL_DEPENDENCY_FILE11)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE11) \
	$(IDL_DEPS_FLAGS11) -t gnuidl -DMAKEDEPEND $(IDL_DEPS11)
	@if cmp -s $(IDL_DEPENDENCY_FILE11) $(IDL_DEPENDENCY_FILE11)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS11)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS11)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE11)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE12)_idl.old
	@cp $(IDL_DEPENDENCY_FILE12) $(IDL_DEPENDENCY_FILE12)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE12) \
	$(IDL_DEPS_FLAGS12) -t gnuidl -DMAKEDEPEND $(IDL_DEPS12)
	@if cmp -s $(IDL_DEPENDENCY_FILE12) $(IDL_DEPENDENCY_FILE12)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS12)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS12)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE12)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE13)_idl.old
	@cp $(IDL_DEPENDENCY_FILE13) $(IDL_DEPENDENCY_FILE13)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE13) \
	$(IDL_DEPS_FLAGS13) -t gnuidl -DMAKEDEPEND $(IDL_DEPS13)
	@if cmp -s $(IDL_DEPENDENCY_FILE13) $(IDL_DEPENDENCY_FILE13)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS13)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS13)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE13)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE14)_idl.old
	@cp $(IDL_DEPENDENCY_FILE14) $(IDL_DEPENDENCY_FILE14)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE14) \
	$(IDL_DEPS_FLAGS14) -t gnuidl -DMAKEDEPEND $(IDL_DEPS14)
	@if cmp -s $(IDL_DEPENDENCY_FILE14) $(IDL_DEPENDENCY_FILE14)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS14)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS14)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE14)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE15)_idl.old
	@cp $(IDL_DEPENDENCY_FILE15) $(IDL_DEPENDENCY_FILE15)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE15) \
	$(IDL_DEPS_FLAGS15) -t gnuidl -DMAKEDEPEND $(IDL_DEPS15)
	@if cmp -s $(IDL_DEPENDENCY_FILE15) $(IDL_DEPENDENCY_FILE15)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS15)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS15)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE15)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE16)_idl.old
	@cp $(IDL_DEPENDENCY_FILE16) $(IDL_DEPENDENCY_FILE16)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE16) \
	$(IDL_DEPS_FLAGS16) -t gnuidl -DMAKEDEPEND $(IDL_DEPS16)
	@if cmp -s $(IDL_DEPENDENCY_FILE16) $(IDL_DEPENDENCY_FILE16)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS16)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS16)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE16)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE17)_idl.old
	@cp $(IDL_DEPENDENCY_FILE17) $(IDL_DEPENDENCY_FILE17)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE17) \
	$(IDL_DEPS_FLAGS17) -t gnuidl -DMAKEDEPEND $(IDL_DEPS17)
	@if cmp -s $(IDL_DEPENDENCY_FILE17) $(IDL_DEPENDENCY_FILE17)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS17)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS17)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE17)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE18)_idl.old
	@cp $(IDL_DEPENDENCY_FILE18) $(IDL_DEPENDENCY_FILE18)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE18) \
	$(IDL_DEPS_FLAGS18) -t gnuidl -DMAKEDEPEND $(IDL_DEPS18)
	@if cmp -s $(IDL_DEPENDENCY_FILE18) $(IDL_DEPENDENCY_FILE18)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS18)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS18)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE18)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE19)_idl.old
	@cp $(IDL_DEPENDENCY_FILE19) $(IDL_DEPENDENCY_FILE19)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE19) \
	$(IDL_DEPS_FLAGS19) -t gnuidl -DMAKEDEPEND $(IDL_DEPS19)
	@if cmp -s $(IDL_DEPENDENCY_FILE19) $(IDL_DEPENDENCY_FILE19)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS19)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS19)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE19)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE20)_idl.old
	@cp $(IDL_DEPENDENCY_FILE20) $(IDL_DEPENDENCY_FILE20)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE20) \
	$(IDL_DEPS_FLAGS20) -t gnuidl -DMAKEDEPEND $(IDL_DEPS20)
	@if cmp -s $(IDL_DEPENDENCY_FILE20) $(IDL_DEPENDENCY_FILE20)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS20)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS20)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE20)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE21)_idl.old
	@cp $(IDL_DEPENDENCY_FILE21) $(IDL_DEPENDENCY_FILE21)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE21) \
	$(IDL_DEPS_FLAGS21) -t gnuidl -DMAKEDEPEND $(IDL_DEPS21)
	@if cmp -s $(IDL_DEPENDENCY_FILE21) $(IDL_DEPENDENCY_FILE21)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS21)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS21)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE21)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE22)_idl.old
	@cp $(IDL_DEPENDENCY_FILE22) $(IDL_DEPENDENCY_FILE22)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE22) \
	$(IDL_DEPS_FLAGS22) -t gnuidl -DMAKEDEPEND $(IDL_DEPS22)
	@if cmp -s $(IDL_DEPENDENCY_FILE22) $(IDL_DEPENDENCY_FILE22)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS22)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS22)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE22)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE23)_idl.old
	@cp $(IDL_DEPENDENCY_FILE23) $(IDL_DEPENDENCY_FILE23)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE23) \
	$(IDL_DEPS_FLAGS23) -t gnuidl -DMAKEDEPEND $(IDL_DEPS23)
	@if cmp -s $(IDL_DEPENDENCY_FILE23) $(IDL_DEPENDENCY_FILE23)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS23)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS23)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE23)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE24)_idl.old
	@cp $(IDL_DEPENDENCY_FILE24) $(IDL_DEPENDENCY_FILE24)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE24) \
	$(IDL_DEPS_FLAGS24) -t gnuidl -DMAKEDEPEND $(IDL_DEPS24)
	@if cmp -s $(IDL_DEPENDENCY_FILE24) $(IDL_DEPENDENCY_FILE24)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS24)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS24)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE24)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE25)_idl.old
	@cp $(IDL_DEPENDENCY_FILE25) $(IDL_DEPENDENCY_FILE25)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE25) \
	$(IDL_DEPS_FLAGS25) -t gnuidl -DMAKEDEPEND $(IDL_DEPS25)
	@if cmp -s $(IDL_DEPENDENCY_FILE25) $(IDL_DEPENDENCY_FILE25)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS25)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS25)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE25)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE26)_idl.old
	@cp $(IDL_DEPENDENCY_FILE26) $(IDL_DEPENDENCY_FILE26)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE26) \
	$(IDL_DEPS_FLAGS26) -t gnuidl -DMAKEDEPEND $(IDL_DEPS26)
	@if cmp -s $(IDL_DEPENDENCY_FILE26) $(IDL_DEPENDENCY_FILE26)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS26)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS26)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE26)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE27)_idl.old
	@cp $(IDL_DEPENDENCY_FILE27) $(IDL_DEPENDENCY_FILE27)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE27) \
	$(IDL_DEPS_FLAGS27) -t gnuidl -DMAKEDEPEND $(IDL_DEPS27)
	@if cmp -s $(IDL_DEPENDENCY_FILE27) $(IDL_DEPENDENCY_FILE27)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS27)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS27)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE27)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE28)_idl.old
	@cp $(IDL_DEPENDENCY_FILE28) $(IDL_DEPENDENCY_FILE28)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE28) \
	$(IDL_DEPS_FLAGS28) -t gnuidl -DMAKEDEPEND $(IDL_DEPS28)
	@if cmp -s $(IDL_DEPENDENCY_FILE28) $(IDL_DEPENDENCY_FILE28)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS28)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS28)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE28)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE29)_idl.old
	@cp $(IDL_DEPENDENCY_FILE29) $(IDL_DEPENDENCY_FILE29)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE29) \
	$(IDL_DEPS_FLAGS29) -t gnuidl -DMAKEDEPEND $(IDL_DEPS29)
	@if cmp -s $(IDL_DEPENDENCY_FILE29) $(IDL_DEPENDENCY_FILE29)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS29)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS29)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE29)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE30)_idl.old
	@cp $(IDL_DEPENDENCY_FILE30) $(IDL_DEPENDENCY_FILE30)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE30) \
	$(IDL_DEPS_FLAGS30) -t gnuidl -DMAKEDEPEND $(IDL_DEPS30)
	@if cmp -s $(IDL_DEPENDENCY_FILE30) $(IDL_DEPENDENCY_FILE30)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS30)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS30)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE30)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE31)_idl.old
	@cp $(IDL_DEPENDENCY_FILE31) $(IDL_DEPENDENCY_FILE31)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE31) \
	$(IDL_DEPS_FLAGS31) -t gnuidl -DMAKEDEPEND $(IDL_DEPS31)
	@if cmp -s $(IDL_DEPENDENCY_FILE31) $(IDL_DEPENDENCY_FILE31)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS31)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS31)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE31)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE32)_idl.old
	@cp $(IDL_DEPENDENCY_FILE32) $(IDL_DEPENDENCY_FILE32)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE32) \
	$(IDL_DEPS_FLAGS32) -t gnuidl -DMAKEDEPEND $(IDL_DEPS32)
	@if cmp -s $(IDL_DEPENDENCY_FILE32) $(IDL_DEPENDENCY_FILE32)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS32)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS32)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE32)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE33)_idl.old
	@cp $(IDL_DEPENDENCY_FILE33) $(IDL_DEPENDENCY_FILE33)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE33) \
	$(IDL_DEPS_FLAGS33) -t gnuidl -DMAKEDEPEND $(IDL_DEPS33)
	@if cmp -s $(IDL_DEPENDENCY_FILE33) $(IDL_DEPENDENCY_FILE33)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS33)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS33)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE33)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE34)_idl.old
	@cp $(IDL_DEPENDENCY_FILE34) $(IDL_DEPENDENCY_FILE34)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE34) \
	$(IDL_DEPS_FLAGS34) -t gnuidl -DMAKEDEPEND $(IDL_DEPS34)
	@if cmp -s $(IDL_DEPENDENCY_FILE34) $(IDL_DEPENDENCY_FILE34)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS34)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS34)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE34)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE35)_idl.old
	@cp $(IDL_DEPENDENCY_FILE35) $(IDL_DEPENDENCY_FILE35)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE35) \
	$(IDL_DEPS_FLAGS35) -t gnuidl -DMAKEDEPEND $(IDL_DEPS35)
	@if cmp -s $(IDL_DEPENDENCY_FILE35) $(IDL_DEPENDENCY_FILE35)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS35)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS35)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE35)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE36)_idl.old
	@cp $(IDL_DEPENDENCY_FILE36) $(IDL_DEPENDENCY_FILE36)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE36) \
	$(IDL_DEPS_FLAGS36) -t gnuidl -DMAKEDEPEND $(IDL_DEPS36)
	@if cmp -s $(IDL_DEPENDENCY_FILE36) $(IDL_DEPENDENCY_FILE36)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS36)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS36)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE36)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE37)_idl.old
	@cp $(IDL_DEPENDENCY_FILE37) $(IDL_DEPENDENCY_FILE37)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE37) \
	$(IDL_DEPS_FLAGS37) -t gnuidl -DMAKEDEPEND $(IDL_DEPS37)
	@if cmp -s $(IDL_DEPENDENCY_FILE37) $(IDL_DEPENDENCY_FILE37)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS37)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS37)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE37)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE38)_idl.old
	@cp $(IDL_DEPENDENCY_FILE38) $(IDL_DEPENDENCY_FILE38)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE38) \
	$(IDL_DEPS_FLAGS38) -t gnuidl -DMAKEDEPEND $(IDL_DEPS38)
	@if cmp -s $(IDL_DEPENDENCY_FILE38) $(IDL_DEPENDENCY_FILE38)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS38)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS38)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE38)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE39)_idl.old
	@cp $(IDL_DEPENDENCY_FILE39) $(IDL_DEPENDENCY_FILE39)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE39) \
	$(IDL_DEPS_FLAGS39) -t gnuidl -DMAKEDEPEND $(IDL_DEPS39)
	@if cmp -s $(IDL_DEPENDENCY_FILE39) $(IDL_DEPENDENCY_FILE39)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS39)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS39)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE39)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE40)_idl.old
	@cp $(IDL_DEPENDENCY_FILE40) $(IDL_DEPENDENCY_FILE40)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE40) \
	$(IDL_DEPS_FLAGS40) -t gnuidl -DMAKEDEPEND $(IDL_DEPS40)
	@if cmp -s $(IDL_DEPENDENCY_FILE40) $(IDL_DEPENDENCY_FILE40)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS40)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS40)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE40)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE41)_idl.old
	@cp $(IDL_DEPENDENCY_FILE41) $(IDL_DEPENDENCY_FILE41)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE41) \
	$(IDL_DEPS_FLAGS41) -t gnuidl -DMAKEDEPEND $(IDL_DEPS41)
	@if cmp -s $(IDL_DEPENDENCY_FILE41) $(IDL_DEPENDENCY_FILE41)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS41)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS41)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE41)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE42)_idl.old
	@cp $(IDL_DEPENDENCY_FILE42) $(IDL_DEPENDENCY_FILE42)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE42) \
	$(IDL_DEPS_FLAGS42) -t gnuidl -DMAKEDEPEND $(IDL_DEPS42)
	@if cmp -s $(IDL_DEPENDENCY_FILE42) $(IDL_DEPENDENCY_FILE42)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS42)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS42)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE42)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE43)_idl.old
	@cp $(IDL_DEPENDENCY_FILE43) $(IDL_DEPENDENCY_FILE43)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE43) \
	$(IDL_DEPS_FLAGS43) -t gnuidl -DMAKEDEPEND $(IDL_DEPS43)
	@if cmp -s $(IDL_DEPENDENCY_FILE43) $(IDL_DEPENDENCY_FILE43)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS43)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS43)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE43)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE44)_idl.old
	@cp $(IDL_DEPENDENCY_FILE44) $(IDL_DEPENDENCY_FILE44)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE44) \
	$(IDL_DEPS_FLAGS44) -t gnuidl -DMAKEDEPEND $(IDL_DEPS44)
	@if cmp -s $(IDL_DEPENDENCY_FILE44) $(IDL_DEPENDENCY_FILE44)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS44)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS44)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE44)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE45)_idl.old
	@cp $(IDL_DEPENDENCY_FILE45) $(IDL_DEPENDENCY_FILE45)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE45) \
	$(IDL_DEPS_FLAGS45) -t gnuidl -DMAKEDEPEND $(IDL_DEPS45)
	@if cmp -s $(IDL_DEPENDENCY_FILE45) $(IDL_DEPENDENCY_FILE45)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS45)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS45)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE45)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE46)_idl.old
	@cp $(IDL_DEPENDENCY_FILE46) $(IDL_DEPENDENCY_FILE46)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE46) \
	$(IDL_DEPS_FLAGS46) -t gnuidl -DMAKEDEPEND $(IDL_DEPS46)
	@if cmp -s $(IDL_DEPENDENCY_FILE46) $(IDL_DEPENDENCY_FILE46)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS46)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS46)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE46)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE47)_idl.old
	@cp $(IDL_DEPENDENCY_FILE47) $(IDL_DEPENDENCY_FILE47)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE47) \
	$(IDL_DEPS_FLAGS47) -t gnuidl -DMAKEDEPEND $(IDL_DEPS47)
	@if cmp -s $(IDL_DEPENDENCY_FILE47) $(IDL_DEPENDENCY_FILE47)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS47)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS47)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE47)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE48)_idl.old
	@cp $(IDL_DEPENDENCY_FILE48) $(IDL_DEPENDENCY_FILE48)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE48) \
	$(IDL_DEPS_FLAGS48) -t gnuidl -DMAKEDEPEND $(IDL_DEPS48)
	@if cmp -s $(IDL_DEPENDENCY_FILE48) $(IDL_DEPENDENCY_FILE48)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS48)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS48)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE48)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE49)_idl.old
	@cp $(IDL_DEPENDENCY_FILE49) $(IDL_DEPENDENCY_FILE49)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE49) \
	$(IDL_DEPS_FLAGS49) -t gnuidl -DMAKEDEPEND $(IDL_DEPS49)
	@if cmp -s $(IDL_DEPENDENCY_FILE49) $(IDL_DEPENDENCY_FILE49)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS49)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS49)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE49)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE50)_idl.old
	@cp $(IDL_DEPENDENCY_FILE50) $(IDL_DEPENDENCY_FILE50)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE50) \
	$(IDL_DEPS_FLAGS50) -t gnuidl -DMAKEDEPEND $(IDL_DEPS50)
	@if cmp -s $(IDL_DEPENDENCY_FILE50) $(IDL_DEPENDENCY_FILE50)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS50)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS50)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE50)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE51)_idl.old
	@cp $(IDL_DEPENDENCY_FILE51) $(IDL_DEPENDENCY_FILE51)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE51) \
	$(IDL_DEPS_FLAGS51) -t gnuidl -DMAKEDEPEND $(IDL_DEPS51)
	@if cmp -s $(IDL_DEPENDENCY_FILE51) $(IDL_DEPENDENCY_FILE51)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS51)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS51)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE51)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE52)_idl.old
	@cp $(IDL_DEPENDENCY_FILE52) $(IDL_DEPENDENCY_FILE52)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE52) \
	$(IDL_DEPS_FLAGS52) -t gnuidl -DMAKEDEPEND $(IDL_DEPS52)
	@if cmp -s $(IDL_DEPENDENCY_FILE52) $(IDL_DEPENDENCY_FILE52)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS52)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS52)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE52)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE53)_idl.old
	@cp $(IDL_DEPENDENCY_FILE53) $(IDL_DEPENDENCY_FILE53)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE53) \
	$(IDL_DEPS_FLAGS53) -t gnuidl -DMAKEDEPEND $(IDL_DEPS53)
	@if cmp -s $(IDL_DEPENDENCY_FILE53) $(IDL_DEPENDENCY_FILE53)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS53)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS53)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE53)_idl.old ;
	@$(RM) $(IDL_DEPENDENCY_FILE54)_idl.old
	@cp $(IDL_DEPENDENCY_FILE54) $(IDL_DEPENDENCY_FILE54)_idl.old
	$(DEPGEN_ENV) $(DEPGEN) -A $(DEPEND_CMD_ARGS) -f $(IDL_DEPENDENCY_FILE54) \
	$(IDL_DEPS_FLAGS54) -t gnuidl -DMAKEDEPEND $(IDL_DEPS54)
	@if cmp -s $(IDL_DEPENDENCY_FILE54) $(IDL_DEPENDENCY_FILE54)_idl.old ;\
	then echo "GNUmakefile idl dependencies unchanged for $(IDL_DEPS54)." ;\
	else \
		echo "GNUmakefile idl dependencies updated for $(IDL_DEPS54)." ;\
	fi ;\
	$(RM) $(IDL_DEPENDENCY_FILE54)_idl.old ;

realclean: clean
ifneq ($(GENERATED_DIRTY),)
	-$(RM) -r $(GENERATED_DIRTY)
endif

__prebuild__:
ifeq ($(corba_messaging),1)
	@-:
endif


.PHONY: install
install: all
INSTALL_LIB ?= lib
ifneq ($(INSTALL_PREFIX),)
ifneq ($(install_rpath),0)
LD_RPATH ?= -Wl,-rpath,
LDFLAGS += $(LD_RPATH)$(INSTALL_PREFIX)/$(INSTALL_LIB) $(LD_RPATH_FLAGS)
endif
endif


